var documenterSearchIndex = {"docs":
[{"location":"#WaveAcoustics.jl","page":"Home","title":"WaveAcoustics.jl","text":"Welcome to WaveAcoustics.jl documentation!","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This package provides finite element methods for solving acoustic wave equations...\n\n[Model description and main equation here - brief overview]","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using WaveAcoustics\n\nmesh = CartesianMesh((0.0,), (1.0,), (10,))","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Multiple FE families (Lagrange, Hermite)\n1D and 2D domains\nVarious boundary conditions\n...","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"theory/model.md\", \"methods/overview.md\", \"examples/overview.md\", \"api/api.md\"]\nDepth = 2","category":"section"},{"location":"api/api/#API-Reference","page":"API Reference","title":"API Reference","text":"Documentation for WaveAcoustics.\n\n","category":"section"},{"location":"api/api/#Mesh","page":"API Reference","title":"Mesh","text":"","category":"section"},{"location":"api/api/#Finite-Element-Families","page":"API Reference","title":"Finite Element Families","text":"","category":"section"},{"location":"api/api/#Basis-Functions","page":"API Reference","title":"Basis Functions","text":"","category":"section"},{"location":"api/api/#1D-Lagrange-Elements","page":"API Reference","title":"1D Lagrange Elements","text":"","category":"section"},{"location":"api/api/#2D-Lagrange-Elements","page":"API Reference","title":"2D Lagrange Elements","text":"","category":"section"},{"location":"api/api/#1D-Hermite-Elements","page":"API Reference","title":"1D Hermite Elements","text":"","category":"section"},{"location":"api/api/#2D-Hermite-Elements","page":"API Reference","title":"2D Hermite Elements","text":"","category":"section"},{"location":"api/api/#Boundary-Conditions","page":"API Reference","title":"Boundary Conditions","text":"","category":"section"},{"location":"api/api/#DOF-Map","page":"API Reference","title":"DOF Map","text":"","category":"section"},{"location":"api/api/#Quadrature-Setup","page":"API Reference","title":"Quadrature Setup","text":"","category":"section"},{"location":"api/api/#Assemble-local-matrices","page":"API Reference","title":"Assemble local matrices","text":"","category":"section"},{"location":"api/api/#Assemble-global-matrices","page":"API Reference","title":"Assemble global matrices","text":"","category":"section"},{"location":"api/api/#Assemble-global-vectors","page":"API Reference","title":"Assemble global vectors","text":"","category":"section"},{"location":"api/api/#Initial-Solution","page":"API Reference","title":"Initial Solution","text":"","category":"section"},{"location":"api/api/#PDE-Input-Data","page":"API Reference","title":"PDE Input Data","text":"","category":"section"},{"location":"api/api/#PDE-Solve","page":"API Reference","title":"PDE Solve","text":"","category":"section"},{"location":"api/api/#EDO-Solve","page":"API Reference","title":"EDO Solve","text":"","category":"section"},{"location":"api/api/#Crank-Nicolson-Method","page":"API Reference","title":"Crank-Nicolson Method","text":"","category":"section"},{"location":"api/api/#Error-norms","page":"API Reference","title":"Error norms","text":"","category":"section"},{"location":"api/api/#Convergence-test","page":"API Reference","title":"Convergence test","text":"","category":"section"},{"location":"api/api/#WaveAcoustics.AbstractMesh","page":"API Reference","title":"WaveAcoustics.AbstractMesh","text":"AbstractMesh{Dim}\n\nAbstract supertype for meshes in dimension Dim.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.CartesianMesh","page":"API Reference","title":"WaveAcoustics.CartesianMesh","text":"CartesianMesh{Dim,I} <: AbstractMesh{Dim}\n\nUniform Cartesian mesh in dimension Dim with integer type I.\n\nFields\n\npmin::NTuple{Dim,Float64}: Domain lower corner\npmax::NTuple{Dim,Float64}: Domain upper corner\nNx::NTuple{Dim,I}: Number of elements per direction\nΔx::NTuple{Dim,Float64}: Element sizes per direction\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.CartesianMesh-Union{Tuple{I}, Tuple{Dim}, Tuple{NTuple{Dim, Float64}, NTuple{Dim, Float64}, NTuple{Dim, I}}} where {Dim, I<:Integer}","page":"API Reference","title":"WaveAcoustics.CartesianMesh","text":"CartesianMesh(pmin, pmax, Nx)\n\nConstruct uniform Cartesian mesh partitioning [pmin, pmax] (1D) or  [pmin[1], pmax[1]] × [pmin[2], pmax[2]] (2D) into Nx elements per direction.\n\nArguments\n\npmin::NTuple{Dim,Float64}: Domain lower corner\npmax::NTuple{Dim,Float64}: Domain upper corner\nNx::NTuple{Dim,I}: Number of elements per direction\n\nExamples\n\njulia> mesh1d = WaveAcoustics.CartesianMesh((0.0,), (1.0,), (10,));\n\njulia> mesh1d.Δx\n(0.1,)\n\njulia> mesh2d = WaveAcoustics.CartesianMesh((0.0, 0.0), (1.0, 2.0), (10, 20));\n\njulia> mesh2d.Δx\n(0.1, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.FEFamily","page":"API Reference","title":"WaveAcoustics.FEFamily","text":"FEFamily\n\nAbstract supertype for finite element families.\n\nConcrete subtypes must specify spatial dimension Dim and polynomial degree Deg.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.Hermite","page":"API Reference","title":"WaveAcoustics.Hermite","text":"Hermite{Dim,Deg} <: FEFamily\n\nHermite finite element of dimension Dim and degree Deg.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.Lagrange","page":"API Reference","title":"WaveAcoustics.Lagrange","text":"Lagrange{Dim,Deg} <: FEFamily\n\nLagrange finite element of dimension Dim and degree Deg.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.num_local_dof","page":"API Reference","title":"WaveAcoustics.num_local_dof","text":"num_local_dof(family::FEFamily)\n\nReturn number of local DOFs for the finite element family.\n\nExamples\n\njulia> WaveAcoustics.num_local_dof(Lagrange{2,3}())\n16\n\njulia> WaveAcoustics.num_local_dof(Hermite{1,3}())\n4\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.polynomial_degree","page":"API Reference","title":"WaveAcoustics.polynomial_degree","text":"polynomial_degree(family::FEFamily)\n\nReturn polynomial degree for the finite element family.\n\nExamples\n\njulia> WaveAcoustics.polynomial_degree(Lagrange{2,3}())\n3\n\njulia> WaveAcoustics.polynomial_degree(Hermite{1,3}())\n3\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Lagrange{1,1}, ξ)\n\nLinear Lagrange basis functions on the reference interval [-1, 1].\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{2,T}: Values of the two basis functions [ϕ₁(ξ), ϕ₂(ξ)]\n\nNode Layout\n\n1 --- 2\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Lagrange{1,1}, ξ)\n\nDerivatives of linear Lagrange basis functions with respect to ξ.\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{2,T}: Derivatives [dϕ₁/dξ, dϕ₂/dξ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Lagrange{1,2}, ξ)\n\nQuadratic Lagrange basis functions on the reference interval [-1, 1].\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{3,T}: Values of the three basis functions [ϕ₁(ξ), ϕ₂(ξ), ϕ₃(ξ)]\n\nNode Layout\n\n1 --- 2 --- 3\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Lagrange{1,2}, ξ)\n\nDerivatives of quadratic Lagrange basis functions with respect to ξ.\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{3,T}: Derivatives [dϕ₁/dξ, dϕ₂/dξ, dϕ₃/dξ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Lagrange{1,3}, ξ)\n\nCubic Lagrange basis functions on the reference interval [-1, 1].\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{4,T}: Values of the four basis functions [ϕ₁(ξ), ϕ₂(ξ), ϕ₃(ξ), ϕ₄(ξ)]\n\nNode Layout\n\n1 --- 2 --- 3 --- 4\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Lagrange{1,3}, ξ)\n\nDerivatives of cubic Lagrange basis functions with respect to ξ.\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{4,T}: Derivatives [dϕ₁/dξ, dϕ₂/dξ, dϕ₃/dξ, dϕ₄/dξ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T<:Real}","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Lagrange{2,Deg}, ξ, η)\n\nTensor-product Lagrange basis functions on the reference square [-1,1] × [-1,1].\n\nArguments\n\nξ::T: First coordinate in the reference element\nη::T: Second coordinate in the reference element\n\nReturns\n\nSVector{(Deg+1)²,T}: Values of all basis functions\n\nNode Layout (Deg = 1)\n\n3 --- 4\n|     |\n1 --- 2\n\nNode Layout (Deg = 2)\n\n7 --- 8 --- 9\n|     |     |\n4 --- 5 --- 6\n|     |     |\n1 --- 2 --- 3\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T<:Real}","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Lagrange{2,Deg}, ξ, η)\n\nDerivatives of tensor-product Lagrange basis functions.\n\nArguments\n\nξ::T: First coordinate in the reference element\nη::T: Second coordinate in the reference element\n\nReturns\n\nTuple (∂ϕ/∂ξ, ∂ϕ/∂η) where:\n∂ϕ/∂ξ::SVector{(Deg+1)²,T}: Derivatives ∂ϕᵢ/∂ξ\n∂ϕ/∂η::SVector{(Deg+1)²,T}: Derivatives ∂ϕᵢ/∂η\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Hermite{1,3}, ξ)\n\nCubic Hermite basis functions on the reference interval [-1, 1].\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{4,T}: Values [H₁(ξ), H₁'(ξ), H₂(ξ), H₂'(ξ)]\n\nNode Layout\n\n1:2 ---- 3:4\n\nEach node has 2 DOFs: (u, du/dξ)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Hermite{1,3}, ξ)\n\nDerivatives of cubic Hermite basis functions with respect to ξ.\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{4,T}: Derivatives [dH₁/dξ, dH₁'/dξ, dH₂/dξ, dH₂'/dξ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Hermite{2,3}, ξ, η)\n\nBicubic Hermite basis functions on the reference square [-1,1] × [-1,1].\n\nArguments\n\nξ::T: First coordinate in the reference element\nη::T: Second coordinate in the reference element\n\nReturns\n\nSVector{16,T}: Values of all 16 basis functions\n\nNode Layout\n\n 9:12 ---- 13:16\n  |          |\n  |          |\n 1:4  ----  5:8\n\nEach corner node has 4 DOFs: (u, ∂u/∂ξ, ∂u/∂η, ∂²u/∂ξ∂η)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Hermite{2,3}, ξ, η)\n\nDerivatives of Bicubic Hermite basis functions.\n\nArguments\n\nξ::T: First coordinate in the reference element\nη::T: Second coordinate in the reference element\n\nReturns\n\nTuple (∂ϕ/∂ξ, ∂ϕ/∂η) where:\n∂ϕ/∂ξ::SVector{16,T}: Derivatives ∂ϕᵢ/∂ξ\n∂ϕ/∂η::SVector{16,T}: Derivatives ∂ϕᵢ/∂η\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.DirichletSides","page":"API Reference","title":"WaveAcoustics.DirichletSides","text":"DirichletSides\n\nAbstract supertype for domain sides with Dirichlet BCs.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.LeftRight","page":"API Reference","title":"WaveAcoustics.LeftRight","text":"LeftRight <: DirichletSides\n\nDirichlet boundary conditions imposed on the left and right sides of a 1D domain.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.LeftRightBottomTop","page":"API Reference","title":"WaveAcoustics.LeftRightBottomTop","text":"LeftRightBottomTop <: DirichletSides\n\nDirichlet boundary conditions imposed on all four sides (left, right, bottom, and top) of a 2D domain.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.LeftRightTop","page":"API Reference","title":"WaveAcoustics.LeftRightTop","text":"LeftRightTop <: DirichletSides\n\nDirichlet boundary conditions imposed on the left, right, and top sides of a 2D domain.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.DOFMap","page":"API Reference","title":"WaveAcoustics.DOFMap","text":"DOFMap{T <: AbstractVector, I <: Integer}\n\nLocal-to-global DOF mapping with homogeneous Dirichlet BCs enforced on the FE approximation subspace.\n\nFields\n\nEQoLG::T: Element connectivity. EQoLG[e][a] gives global index of local DOF a in element e\nm::I: Number of free DOFs after homogeneous Dirichlet BC enforcement on the FE approximation subspace\n\nIndexing Convention\n\nGlobal functions in the approximation subspace: indices 1, 2, ..., m\nGlobal functions NOT in the approximation subspace: sentinel value m+1\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.DOFMap-Union{Tuple{I}, Tuple{Dim}, Tuple{WaveAcoustics.CartesianMesh{Dim, I}, WaveAcoustics.FEFamily, WaveAcoustics.DirichletSides}} where {Dim, I<:Integer}","page":"API Reference","title":"WaveAcoustics.DOFMap","text":"DOFMap(mesh::CartesianMesh, family::FEFamily, sides::DirichletSides)\n\nConstruct DOF map for given mesh, element family, and Dirichlet boundary conditions.\n\nArguments\n\nmesh: Cartesian mesh\nfamily: Finite element family (e.g., Lagrange{2,3}())\nsides: Dirichlet boundary condition specification (e.g., LeftRight())\n\nReturns\n\nDOFMap containing element connectivity and number of free DOFs.\n\nExamples\n\njulia> mesh = WaveAcoustics.CartesianMesh((0.0,), (1.0,), (4,));\n\njulia> dofmap = WaveAcoustics.DOFMap(mesh, WaveAcoustics.Lagrange{1,1}(), WaveAcoustics.LeftRight());\n\njulia> dofmap.EQoLG\n4-element Vector{StaticArraysCore.SVector{2, Int64}}:\n [4, 1]\n [1, 2]\n [2, 3]\n [3, 4]\n\njulia> dofmap.m\n3\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.apply_EQ!-Union{Tuple{I}, Tuple{Vector{<:StaticArraysCore.SVector}, Vector{<:StaticArraysCore.SVector}, Vector{I}}} where I<:Integer","page":"API Reference","title":"WaveAcoustics.apply_EQ!","text":"apply_EQ!(EQoLG, LG, EQ)\n\nApply equation numbering to local-to-global map (in-place).\n\nTransforms LG (before BCs) into EQoLG (after BCs) using EQ mapping.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.build_EQ","page":"API Reference","title":"WaveAcoustics.build_EQ","text":"build_EQ(Nx, family, sides)\n\nBuild equation numbering array that enforces homogeneous Dirichlet BCs.\n\nReturns\n\nEQ: Array mapping global DOF index (before BCs) to free DOF index (after BCs)\nm: Number of free DOFs\n\nIndexing Convention\n\nGlobal functions in the approximation subspace: indices 1, 2, ..., m\nGlobal functions NOT in the approximation subspace: sentinel value m+1\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.build_LG","page":"API Reference","title":"WaveAcoustics.build_LG","text":"build_LG(mesh, family)\n\nBuild local-to-global DOF map before BC enforcement.\n\nReturns vector LG where LG[e] contains global DOF indices for element e. Uses tensor product ordering: DOFs numbered left-to-right, bottom-to-top.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.QuadratureSetup","page":"API Reference","title":"WaveAcoustics.QuadratureSetup","text":"QuadratureSetup{T<:Real}\n\nPrecomputed quadrature data for finite element assembly using Gauss-Legendre quadrature.\n\nFields\n\nP, W: Quadrature points and weights in [-1,1].\nϕP, W_ϕP, W_ϕPϕP: 1D basis functions and weighted products.\nφP, W_φP, W_φPφP: 2D basis functions and weighted products\nW_∂φ∂ξP, W_∂φ∂ηP: Weighted basis function derivatives\nxP, yP:  Precomputed fixed part of physical quad points: (Δx/2)*(P+1) + xmin, (Δy/2)*(P+1) + ymin\n\nNotes\n\nCurrently specialized for Npg = 4 Gauss–Legendre points per dimension\nCurrently specialized for linear Lagrange basis functions\nFor element at indices (ex, ey), physical quadrature coordinates are:\n\nxeP = @. xP + (ex - 1) * Δx\nyeP = @. yP + (ey - 1) * Δy\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.QuadratureSetup-Union{Tuple{T}, Tuple{Tuple{T, T}, Tuple{T, T}}} where T<:Real","page":"API Reference","title":"WaveAcoustics.QuadratureSetup","text":"QuadratureSetup(Δx, pmin)\n\nConstruct quadrature setup with 4 Gauss-Legendre points per dimension.\n\nArguments\n\nΔx::NTuple{2,T}: Element sizes per direction\npmin::NTuple{2,T}: Domain bottom-left corner (xmin, ymin)\n\nExamples\n\njulia> quad = WaveAcoustics.QuadratureSetup((0.1, 0.2), (0.0, 0.0));\n\njulia> length(quad.xP)\n4\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_local_matrix_DF!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SMatrix{Npg, Npg, <:StaticArraysCore.SMatrix{nb, nb, T}}, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}}} where {T<:AbstractFloat, I<:Integer, nb, Npg, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_local_matrix_DF!","text":"assembly_local_matrix_DF!(DF, f, d, m, eq, W_φPφP, φP)\n\nDFₐᵦ = ∬ φₐ(ξ,η) φᵦ(ξ,η) f(Uₕ(x(ξ,η),y(ξ,η))) dξ dη over reference element Ω = (-1,1)², with Uₕ(x(ξ,η),y(ξ,η)) = Σ d[eq[j]] φⱼ(ξ,η).\n\nArguments\n\nDF::AbstractMatrix{T}: Local matrix (nb × nb), zeroed and filled in-place only in upper triangle\nf::Fun: Callable f(s) → T\nd::AbstractVector{T}: Coefficient vector for Uₕ, length m\nm::I: Number of active DOFs\neq::SVector{nb,I}: Local-to-global DOF mapping for element e (EQoLG[e])\nW_φPφP::SMatrix{Npg,Npg,<:SMatrix{nb,nb,T}}: Precomputed Wᵢ⋅Wⱼ⋅φₐ(Pᵢ,Pⱼ)⋅φᵦ(Pᵢ,Pⱼ) (NO Jacobian, NO scale)\nφP::SMatrix{Npg,Npg,SVector{nb,T}}: Precomputed φ(Pᵢ,Pⱼ)\n\nType Parameters\n\nT: Floating point type\nI: Integer type\nnb: Number of basis functions per element\nNpg: Number of quadrature points per element in each axis direction \nFun: Function type\n\nNotes\n\nScaling factor and Jacobian are NOT applied here\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_local_matrix_DG!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SVector{Npg, T}, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, I<:Integer, nb, Npg, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_local_matrix_DG!","text":"assembly_local_matrix_DG!(DG, ∂ₛg, v, m, eq, xeP, W_ϕPϕP, ϕP)\n\nDGₐᵦ = ∫ ϕₐ(ξ) * ϕᵦ(ξ) * ∂ₛg(x(ξ), Vₕ(x(ξ))) dx over Ω = (-1,1), with Vₕ(x(ξ)) = Σ v[eq[j]] ϕⱼ(ξ).\n\nArguments\n\nDG::AbstractMatrix{T}: Local matrix (nb × nb), zeroed and filled in-place only in upper triangle\n∂ₛg::Fun: Callable ∂ₛg(x, s) → T\nv::AbstractVector{T}: Coefficient vector for Vₕ, length m\nm::I: Number of active DOFs\neq::SVector{nb,I}: Local-to-global DOF mapping for element e (EQoLG[e])\nxeP::SVector{Npg,T}: Physical quadrature points (xᵉ(P) = (Δx/2)*(P + 1) + x_start + (e-1)*Δx)\nquad::QuadratureSetup: Precomputed quadrature data\n\nType Parameters\n\nT: Floating point type\nI: Integer type\nnb: Number of basis functions per element\nNpg: Number of quadrature points per element\nFun: Function type\n\nNotes\n\nScaling factor and Jacobian are NOT applied here\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_local_matrix_ϕxϕ","page":"API Reference","title":"WaveAcoustics.assembly_local_matrix_ϕxϕ","text":"assembly_local_matrix_ϕxϕ(mesh, family)\n\nAssemble the local mass matrix ∫_{Ωₑ} ϕₐᵉ ϕᵦᵉ dx for an arbitrary element Ωₑ.\n\nArguments\n\nmesh::CartesianMesh{Dim}: Uniform Cartesian mesh defining element geometry\nfamily::FEFamily: Finite element family\n\nReturns\n\nSMatrix{N,N}: Local mass matrix where N = num_local_dof(family)\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ","page":"API Reference","title":"WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ","text":"assembly_local_matrix_∇ϕx∇ϕ(mesh, family)\n\nAssemble the local stiffness matrix ∫_{Ωₑ} ∇ϕₐᵉ · ∇ϕᵦᵉ dx for an arbitrary element Ωₑ.\n\nArguments\n\nmesh::CartesianMesh{Dim}: Uniform Cartesian mesh defining element geometry\nfamily::FEFamily: Finite element family\n\nReturns\n\nSMatrix{N,N}: Local stiffness matrix where N = num_local_dof(family)\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{LinearAlgebra.Symmetric{T, <:StaticArraysCore.SMatrix{N, N, T}}, WaveAcoustics.DOFMap{<:AbstractVector, I}}} where {N, T, I<:Integer}","page":"API Reference","title":"WaveAcoustics.assembly_global_matrix","text":"assembly_global_matrix(local_matrix, dof_map) -> Symmetric{T, SparseMatrixCSC{T,I}}\n\nAssemble global symmetric FEM matrix from element-local symmetric matrix. Only stores upper triangle, reducing memory and assembly time.\n\nArguments\n\nlocal_matrix::Symmetric{T, <:SMatrix{N,N,T}}: Symmetric element matrix (N×N)\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\n\nReturns\n\nSymmetric{T, SparseMatrixCSC{T,I}}: Assembled symmetric global matrix (m×m)\n\nAssumptions\n\nAssumes a ≤ b ⇒ ia ≤ jb for all local indices, where ia = EQoLG[e][a] and  jb = EQoLG[e][b]. This condition holds for structured meshes with consistent  left-to-right, bottom-to-top numbering.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, N, T}, WaveAcoustics.DOFMap{<:AbstractVector, I}}} where {N, T, I<:Integer}","page":"API Reference","title":"WaveAcoustics.assembly_global_matrix","text":"assembly_global_matrix(local_matrix, dof_map) -> SparseMatrixCSC\n\nAssemble global FEM matrix from element-local matrix.\n\nArguments\n\nlocal_matrix::SMatrix{N,N,T}: Element matrix (N×N)\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\n\nReturns\n\nSparseMatrixCSC{T,I}: Assembled global matrix (m×m), excluding DOFs > m\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_global_matrix_DF-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, I<:Integer, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_global_matrix_DF","text":"assembly_global_matrix_DF(scale, f, d, mesh, dof_map, quad)\n\nDFᵢⱼ = scale * ∬ φᵢ(x,y) * φⱼ(x,y) * f(Uₕ(x,y)) dx dy over Ω, with Uₕ(x,y) = Σ d[k] φₖ(x,y).\n\nArguments\n\nscale::T: Scaling factor applied to final result\nf::Fun: Callable f(s) → T\nd::AbstractVector{T}: Coefficient vector for Uₕ, length dof_map.m\nmesh::CartesianMesh{2, I}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\nReturns\n\nSymmetric{T, SparseMatrixCSC{T,I}}: Assembled symmetric global matrix (m×m)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_global_matrix_DG-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, I<:Integer, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_global_matrix_DG","text":"assembly_global_matrix_DG(scale, ∂ₛg, v, mesh, dof_map, quad)\n\nDGᵢⱼ = scale * ∫ ϕᵢ(x) * ϕⱼ(x) * ∂ₛg(x, Vₕ(x)) dx over Ω ⊂ ℜ, with Vₕ(x) = Σ v[k] ϕₖ(x).\n\nArguments\n\nscale::T: Scaling factor applied to final result\n∂ₛg::Fun: Callable ∂ₛg(x, v) → T\nv::AbstractVector{T}: Coefficient vector for Vₕ, length dof_map.m\nmesh::CartesianMesh{1,I}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\nReturns\n\nSymmetric{T, SparseMatrixCSC{T,I}}: Assembled symmetric global matrix (m×m)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_nonlinearity_F!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_nonlinearity_F!","text":"assembly_nonlinearity_F!(F, scale, f, d, mesh, dof_map, quad)\n\nFᵢ = scale * ∬ φᵢ(x,y) * f(Uₕ(x,y)) dx dy over Ω, with Uₕ(x,y) = Σ d[j] φⱼ(x,y).\n\nArguments\n\nF::AbstractVector{T}: Global vector (zeroed and filled in-place), length dof_map.m\nscale::T: Scaling factor applied to final result\nf::Fun: Nonlinearity function f(u) returning type T\nd::AbstractVector{T}: Coefficient vector for Uₕ, length dof_map.m\nmesh::CartesianMesh{2}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_nonlinearity_G!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_nonlinearity_G!","text":"assembly_nonlinearity_G!(G, scale, g, v, mesh, dof_map, quad)\n\nGᵢ = scale * ∫ ϕᵢ(x) * g(x, Vₕ(x)) dx over Ω = (0,1), with Vₕ(x) = Σ v[j] ϕⱼ(x).\n\nArguments\n\nG::AbstractVector{T}: Global vector (zeroed and filled in-place), length dof_map.m\nscale::T: Scaling factor applied to final result\ng::Fun: Callable g(x, v) → scalar\nv::AbstractVector{T}: Coefficient vector for Vₕ, length dof_map.m\nmesh::CartesianMesh{1}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_rhs_1d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg}, StaticArraysCore.SVector{nb, T}, 1, Npg}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}}} where {T<:Real, Npg, nb, I<:Integer, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_rhs_1d!","text":"assembly_rhs_1d!(F, f, scale, W_basisP, mesh, dof_map, xP)\n\nAssemble global RHS vector for 1D FEM by integrating f(x) against basis functions.\n\nArguments\n\nF::AbstractVector{T}: Global RHS vector (modified in-place, length dof_map.m)\nf::Fun: Source function f(x) returning type T\nscale::T: Scaling factor (typically Δx/2 for F[i] = ∫Ω f(x) ϕᵢ(x) dx)\nW_basisP::SVector{Npg,SVector{nb,T}}: Precomputed weighted basis evaluations at quadrature points\nmesh::CartesianMesh{1,I}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nxP::SVector{Npg,T}: Precomputed fixed part of physical quad points: (Δx/2)*(P+1) + x_start\n\nType Parameters\n\nT: Floating point type for computations\nNpg: Number of quadrature points per element\nnb: Number of local basis functions per element\nI: Integer type for mesh indexing\nFun: Function type for source term\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_rhs_2d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}, StaticArraysCore.SVector{Npg, T}}} where {T<:Real, Npg, nb, I<:Integer, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_rhs_2d!","text":"assembly_rhs_2d!(F, f, scale, W_basisP, mesh, dof_map, xP, yP)\n\nAssemble global RHS vector for 2D FEM by integrating f(x,y) against basis functions.\n\nArguments\n\nF::AbstractVector{T}: Global RHS vector (modified in-place, length dof_map.m)\nf::Fun: Source function f(x,y) returning type T\nscale::T: Scaling factor (typically Δx*Δy/4 for F[i] = ∫Ω f(x,y) φᵢ(x,y) dx dy)\nW_basisP::SMatrix{Npg,Npg,SVector{nb,T}}: Precomputed weighted basis evaluations at quadrature points\nmesh::CartesianMesh{2,I}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nxP::SVector{Npg,T}: Precomputed fixed part of physical quad points: (Δx/2)*(P+1) + x_start\nyP::SVector{Npg,T}: Precomputed fixed part of physical quad points: (Δy/2)*(P+1) + y_start\n\nType Parameters\n\nT: Floating point type for computations\nNpg: Number of quadrature points per element\nnb: Number of local basis functions per element\nI: Integer type for mesh indexing\nFun: Function type for source term\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_r⁰_z⁰!-NTuple{7, Any}","page":"API Reference","title":"WaveAcoustics.compute_r⁰_z⁰!","text":"compute_r⁰_z⁰!(r⁰, z⁰, lhs_mat, input_data, mesh, dof_map, quad)\n\nCompute initial velocity and displacement fields via L2 projection.\n\nArguments\n\nr⁰::AbstractVector: Output vector for initial velocity coefficients (modified in-place, length dof_map.m)\nz⁰::AbstractVector: Output vector for initial displacement coefficients (modified in-place, length dof_map.m)\nlhs_mat: Matrix to be factorized\ninput_data: Structure containing fields r₀, z₀\nmesh::CartesianMesh{1}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_v⁰_d⁰!-NTuple{7, Any}","page":"API Reference","title":"WaveAcoustics.compute_v⁰_d⁰!","text":"compute_v⁰_d⁰!(v⁰, d⁰, lhs_mat, input_data, mesh, dof_map, quad)\n\nCompute initial velocity and displacement fields via H₀¹ projection from gradient data.\n\nArguments\n\nv⁰::AbstractVector: Output vector for initial velocity coefficients (modified in-place, length dof_map.m)\nd⁰::AbstractVector: Output vector for initial displacement coefficients (modified in-place, length dof_map.m)\nlhs_mat: Matrix to be factorized\ninput_data: Structure containing gradient fields ∂ₓv₀, ∂ᵧv₀, ∂ₓu₀, ∂ᵧu₀\nmesh::CartesianMesh{2}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.projection_H01_2d!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{T}, Tuple{AbstractVector{T}, F1, F2, F3, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, AbstractVector{T}, AbstractVector{T}}} where {T, F1, F2, F3}","page":"API Reference","title":"WaveAcoustics.projection_H01_2d!","text":"projection_H01_2d!(uₕ_coefs, ∂ₓu, ∂ᵧu, factorized_lhs_mat, mesh, dof_map, quad, vec₁, vec₂)\n\nCompute the H₀¹ projection of a function onto a finite element subspace given its gradient components.\n\nSolves the weak formulation (∇uₕ, ∇v) = (∇u, ∇v) for all v ∈ Vₕ, where uₕ is the projection and Vₕ is the finite element space.\n\nArguments\n\nuₕ_coefs::AbstractVector{T}: Output vector for FEM coefficients of the projection (modified in-place, length dof_map.m)\n∂ₓu::F1: Partial derivative ∂u/∂x with signature ∂ₓu(x, y) → T\n∂ᵧu::F2: Partial derivative ∂u/∂y with signature ∂ᵧu(x, y) → T\nfactorized_lhs_mat::F3: Factorized matrix (e.g., Cholesky factorization)\nmesh::CartesianMesh{2}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\nvec₁::AbstractVector{T}: Work vector for RHS assembly (modified in-place, length dof_map.m)\nvec₂::AbstractVector{T}: Work vector for RHS assembly (modified in-place, length dof_map.m)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.PDECommonData","page":"API Reference","title":"WaveAcoustics.PDECommonData","text":"PDECommonData{T<:Real, Fα, Ff, Fdf, Fg, F∂ₛg, Fu₀, F∂ₓu₀, F∂ᵧu₀, Fv₀, F∂ₓv₀, F∂ᵧv₀, Fz₀, Fr₀}\n\nCommon configuration for coupled wave-acoustic PDE system.\n\nMathematical Specification\n\nWave equation on rectangular domain Ω = ]xmin,xmax[ × ]ymin,ymax[:\n\nfrac²ut² - α(t)Δu + f(u) = f₁(xyt) quad textin  Ω\n\nwith homogeneous boundary conditions on Γ₀ = ∂Ω \\ Γ₁.\n\nAcoustic equation on bottom boundary Γ₁ = {(x,ymin) : x ∈ ]xmin,xmax[}:\n\nq₁frac²zt² + q₂fraczt + q₃z + q₄v(xymint) = f₂(xt)\n\nwhere v = ∂u/∂t couples the wave velocity at Γ₁ to the acoustic equation.\n\nFields\n\nDomain Configuration\n\npmin::NTuple{2,T}: Bottom-left corner (xmin, ymin). Default: (0, 0)\npmax::NTuple{2,T}: Top-right corner (xmax, ymax). Default: (1, 1)\nt_final::T: Final simulation time. Default: 1\n\nPhysical Parameters\n\nq₁::T: Acoustic acceleration coefficient. Default: 1\nq₂::T: Acoustic velocity coefficient. Default: 1\nq₃::T: Acoustic displacement coefficient. Default: 1\nq₄::T: Wave-acoustic coupling strength. Default: 1\n\nCoefficient Functions\n\nα::Fα: Time-dependent wave diffusion coefficient α(t)\nf::Ff, df::Fdf: Nonlinear wave term f(s) and derivative f'(s)\ng::Fg, ∂ₛg::F∂ₛg: Nonlinear coupling function g(x,s) and s-derivative ∂ₛg(x,s)\n\nWave Initial Conditions (2D functions on Ω)\n\nu₀::Fu₀, ∂ₓu₀::F∂ₓu₀, ∂ᵧu₀::F∂ᵧu₀: Displacement u(x,y,0) and spatial derivatives\nv₀::Fv₀, ∂ₓv₀::F∂ₓv₀, ∂ᵧv₀::F∂ᵧv₀: Velocity v(x,y,0) = ∂ₜu(x,y,0) and spatial derivatives\n\nAcoustic Initial Conditions (1D functions on Γ₁)\n\nz₀::Fz₀: Acoustic displacement z(x,0)\nr₀::Fr₀: Acoustic velocity r(x,0) = ∂ₜz(x,0)\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.PDEInputData","page":"API Reference","title":"WaveAcoustics.PDEInputData","text":"PDEInputData{C<:PDECommonData, Ff₁, Ff₂, Fu, Fv, Fz, Fr}\n\nComplete problem specification including source terms and analytical solutions.\n\nFields\n\ncommon::C: Problem configuration (see PDECommonData)\nf₁::Ff₁: Wave source term f₁(x,y,t) on Ω\nf₂::Ff₂: Acoustic source term f₂(x,t) on Γ₁\nu::Fu, v::Fv: Analytical wave solutions u(x,y,t), v(x,y,t) (if known)\nz::Fz, r::Fr: Analytical acoustic solutions z(x,t), r(x,t) (if known)\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.example1_common_data-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"WaveAcoustics.example1_common_data","text":"example1_common_data([T=Float64]) -> PDECommonData{T}\n\nΩ = ]0,1[², f(s) = s|s|³, g(x,s) = (1+exp(-x²))(sin(s)+2s), u₀(x,y) = (x^2.4 - x) * (y^2.4 - 1) * 4, z₀(x) = sinpi(x).\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.example1_manufactured-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"WaveAcoustics.example1_manufactured","text":"example1_manufactured([T=Float64]) -> PDEInputData{T}\n\nExample 1 with manufactured solutions for convergence study.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.example1_zero_source-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"WaveAcoustics.example1_zero_source","text":"example1_zero_source([T=Float64]) -> PDEInputData{T}\n\nExample 1 with zero source terms for physical simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.manufactured_solution_case-Union{Tuple{T}, Tuple{PDECommonData{T}, Vararg{Any, 6}}} where T","page":"API Reference","title":"WaveAcoustics.manufactured_solution_case","text":"manufactured_solution_case(common, f₁, f₂, u, v, z, r) -> PDEInputData\n\nConstruct problem with manufactured solutions for convergence study.\n\nSource terms f₁ and f₂ are computed by substituting analytical solutions into the governing PDEs (Method of Manufactured Solutions).\n\nArguments\n\ncommon::PDECommonData: Problem configuration\nf₁: Manufactured wave source f₁(x,y,t)\nf₂: Manufactured acoustic source f₂(x,t)\nu, v: Analytical wave solutions u(x,y,t), v(x,y,t)\nz, r: Analytical acoustic solutions z(x,t), r(x,t)\n\nSee also\n\nzero_source_case\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.zero_source_case-Union{Tuple{PDECommonData{T}}, Tuple{T}} where T","page":"API Reference","title":"WaveAcoustics.zero_source_case","text":"zero_source_case(common) -> PDEInputData\n\nConstruct problem with zero source terms (f₁ = f₂ = 0).\n\nNo analytical solution available. Dummy functions returning nothing are used for analytical solution fields.\n\nSee also\n\nmanufactured_solution_case\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.pde_solve-Union{Tuple{T}, Tuple{I}, Tuple{Tuple{I, I}, T, Any}} where {I<:Integer, T<:Real}","page":"API Reference","title":"WaveAcoustics.pde_solve","text":"pde_solve(Nx, τ, input_data)\n\nSolve coupled wave-acoustic PDE system and compute L∞(0,T;L²) errors.\n\nArguments\n\nNx::NTuple{2,Integer}: Number of elements per direction\nτ::Real: Time step size\ninput_data::PDEInputData: Problem configuration with manufactured solution \n\nReturns\n\n(LooL2_v, LooL2_u, LooL2_r, LooL2_z): L∞(0,T;L²) errors\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.CNCache","page":"API Reference","title":"WaveAcoustics.CNCache","text":"CNCache{T}\n\nCache structure for Crank-Nicolson solver.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.CNCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T","page":"API Reference","title":"WaveAcoustics.CNCache","text":"CNCache(m₁::Integer, m₂::Integer, ::Type{T}) where T\n\nConstruct cache with all vectors initialized to zero.\n\nArguments\n\nm₁: Number of free DOFs in 2D domain Ω\nm₂: Number of free DOFs on 1D boundary Γ₁  \nT: Element type\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_A₁₁!-Tuple{AbstractMatrix, AbstractMatrix, Real, Real, AbstractMatrix}","page":"API Reference","title":"WaveAcoustics.compute_A₁₁!","text":"compute_A₁₁!(A₁₁, M_m₁xm₁, τ²_4, α_half, K_m₁xm₁)\n\nCompute system matrix A₁₁ = Mm₁×m₁ + (τ²/4)α(tₙ₊₁/₂)Km₁×m₁.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_A₁₂!-Tuple{AbstractMatrix, Real, Real, AbstractMatrix}","page":"API Reference","title":"WaveAcoustics.compute_A₁₂!","text":"compute_A₁₂!(A₁₂, τ_2, α_half, M_m₁xm₂)\n\nCompute system matrix A₁₂ = -(τ/2)α(tₙ₊₁/₂)M_m₁×m₂.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_DHX₁₁!-NTuple{13, Any}","page":"API Reference","title":"WaveAcoustics.compute_DHX₁₁!","text":"compute_DHX₁₁!(DHX₁₁, A₁₁, v̂ⁿ_m₂, d̂ⁿ, input_data, mesh1D, mesh2D,\n               dof_map_m₁, dof_map_m₂, quad, τα_2, τ²_4, m₂)\n\nDHX₁₁ = A₁₁ + (τ²/4)⋅DF(d̂ⁿ) + (τ/2)α(tₙ₋₁/₂)⋅DG(v̂ⁿ_m₂)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_Lm₁!-NTuple{13, Any}","page":"API Reference","title":"WaveAcoustics.compute_Lm₁!","text":"compute_Lm₁!(Lm₁, vⁿ⁻¹, rⁿ⁻¹, vec_d_v, matrices, input_data, mesh2D, dof_map_m₁, quad, τ, t_half, α_half, cache)\n\nLm₁ = M_m₁×m₁⋅vⁿ⁻¹ - τα(tₙ₊₁/₂)K_m₁×m₁⋅(dⁿ⁻¹+(τ/4)⋅vⁿ⁻¹) + (τ/2)α(tₙ₊₁/₂)M_m₁×m₂⋅rⁿ⁻¹ + τF(f₁(tₙ₊₁/₂))\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_Lm₂!-NTuple{15, Any}","page":"API Reference","title":"WaveAcoustics.compute_Lm₂!","text":"compute_Lm₂!(Lm₂, rⁿ⁻¹, zⁿ⁻¹, vⁿ⁻¹, matrices, input_data, mesh1D, dof_map_m₂, quad, τ, t_half, τq₄_2, τq₃, cst_q, cache)\n\nLm₂ = M_m₂×m₂⋅(cst_q⋅rⁿ⁻¹ - τq₃⋅zⁿ⁻¹) - (τ/2)q₄⋅M_m₂×m₁⋅vⁿ⁻¹ + τ⋅F(f₂(tₙ₊₁/₂))\n\nwhere cst_q = q₁ - (τ/2)q₂ - (τ²/4)q₃.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_minusHX!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Any, Any, Any, Any, Any, Any, T, T, T, WaveAcoustics.CNCache{T}}} where T","page":"API Reference","title":"WaveAcoustics.compute_minusHX!","text":"compute_minusHX!(minusHX, vⁿ, v̂ⁿ_m₂, d̂ⁿ, rⁿ, A₁₁, A₂₂, M_m₂xm₂, Lm₁, Lm₂, \n                 input_data, mesh1D, mesh2D, dof_map_m₁, dof_map_m₂, quad, \n                 τ, τq₄_2, α_half, cache)\n\nCompute negative residual -H(X) for Newton's method.\n\nThe residual H(X) represents the nonlinear system:\n\nH(X) = [A₁₁⋅vⁿ - (τ/2)α(tₙ₊₁/₂)M_m₁×m₂⋅rⁿ + τα(tₙ₊₁/₂)G(v̂ⁿ_m₂) + τF(d̂ⁿ) - Lm₁]\n       [(τ/2)q₄⋅M_m₂×m₁⋅vⁿ + A₂₂⋅rⁿ - Lm₂                                    ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.crank_nicolson-NTuple{12, Any}","page":"API Reference","title":"WaveAcoustics.crank_nicolson","text":"crank_nicolson(v⁰, d⁰, r⁰, z⁰, τ, input_data, mesh1D, mesh2D, \n               dof_map_m₁, dof_map_m₂, quad, matrices)\n\nSolve coupled wave-acoustic PDE system using Crank-Nicolson time integration.\n\nArguments\n\nv⁰::Vector: Initial velocity field\nd⁰::Vector: Initial displacement field  \nr⁰::Vector: Initial boundary velocity\nz⁰::Vector: Initial boundary displacement\nτ::Real: Time step size\ninput_data: Problem configuration with manufactured solution\nmesh1D: 1D mesh for boundary (Γ₀)\nmesh2D: 2D mesh for domain (Ω)\ndof_map_m₁: DOF mapping for 2D space\ndof_map_m₂: DOF mapping for 1D boundary\nquad: Quadrature setup\nmatrices::SystemMatrices: Global assembled matrices\n\nReturns\n\nNamed tuple with L² errors at each time step:\n\nv: Velocity errors\nd: Displacement errors  \nr: Boundary velocity errors\nz: Boundary displacement errors\n\nAlgorithm\n\nUses Crank-Nicolson for time discretization with Newton iteration to handle nonlinearities f(u) and g(x,v).  The method is second-order accurate in time.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.L2_error_1d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:Real, Fun}","page":"API Reference","title":"WaveAcoustics.L2_error_1d","text":"L2_error_1d(u, uₕ_coefs, mesh, dof_map, quad)\n\nCompute the L2 error norm ||u - uₕ||_L2 between exact and FEM solutions.\n\nArguments\n\nu::F: Exact solution function with signature u(x) → T\nuₕ_coefs::AbstractVector{T}: DOF coefficients of the FEM solution (length = dof_map.m)\nmesh::CartesianMesh{1}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\nReturns\n\nT: L2 norm ||u - uₕ||_L2\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.L2_error_2d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:Real, Fun}","page":"API Reference","title":"WaveAcoustics.L2_error_2d","text":"L2_error_2d(u, uₕ_coefs, mesh, dof_map, quad)\n\nCompute the L2 error norm ||u - uₕ||_L2 between exact and FEM solutions.\n\nArguments\n\nu::F: Exact solution function with signature u(x, y) → T\nuₕ_coefs::AbstractVector{T}: DOF coefficients of the FEM solution (length = dof_map.m)\nmesh::CartesianMesh{2}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\nReturns\n\nT: L2 norm ||u - uₕ||_L2\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics._compute_element_diameter-Tuple{Int64, Any, Any}","page":"API Reference","title":"WaveAcoustics._compute_element_diameter","text":"_compute_element_diameter(Nx::Int, pmin, pmax) -> Float64\n\nCompute element diameter h = √(Δx² + Δy²) for uniform rectangular mesh.\n\nElement dimensions Δx and Δy are determined by domain size (pmax - pmin) divided by number of elements Nx in each direction.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics._convergence_test_coupled-Tuple{Any, Any}","page":"API Reference","title":"WaveAcoustics._convergence_test_coupled","text":"_convergence_test_coupled(Nx_exp_range, input_data) -> NamedTuple\n\nExecute coupled space-time convergence test with τ = h.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics._convergence_test_spatial-Tuple{Any, Real, Any}","page":"API Reference","title":"WaveAcoustics._convergence_test_spatial","text":"_convergence_test_spatial(Nx_exp_range, τ_fixed, input_data) -> NamedTuple\n\nExecute spatial convergence test with fixed time step.\n\nVaries mesh size h while keeping temporal discretization τ constant to isolate spatial discretization error.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics._convergence_test_temporal-Tuple{Any, Int64, Any}","page":"API Reference","title":"WaveAcoustics._convergence_test_temporal","text":"_convergence_test_temporal(τ_exp_range, Nx_fixed, input_data) -> NamedTuple\n\nExecute temporal convergence test with fixed spatial grid.\n\nVaries time step τ while keeping mesh size h constant to isolate temporal discretization error.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics._run_convergence_study-Tuple{Any, Any, Any, Any, String}","page":"API Reference","title":"WaveAcoustics._run_convergence_study","text":"_run_convergence_study(Nx_values, h_values, τ_values, input_data, test_info) -> NamedTuple\n\nExecute convergence study computing error norms and convergence rates.\n\nSolves the PDE for each refinement level, computes L∞(L²) error norms for all fields, and calculates convergence rates as log₂(error{i-1} / errori) between successive refinements.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.convergence_test-Tuple{Symbol}","page":"API Reference","title":"WaveAcoustics.convergence_test","text":"convergence_test(test_type::Symbol; kwargs...)\n\nPerform convergence analysis for PDE solvers using method of manufactured solutions.\n\nThree test strategies are available: :coupled varies spatial and temporal discretization together with τ = h (assuming linear basis functions); :spatial varies mesh size h with fixed time step τ; :temporal varies time step τ with fixed mesh size h. Convergence rates are computed as log₂(error{i-1} / errori) between successive refinements.\n\nArguments\n\ntest_type::Symbol: Convergence test strategy - :coupled, :spatial, or :temporal\n\nKeyword Arguments\n\nNx_exp_range: Exponents for grid refinement (e.g., 3:6 gives Nx = 8, 16, 32, 64). Used by :coupled and :spatial tests\nτ_fixed: Fixed time step. Used by :spatial test\nτ_exp_range: Exponents for time step refinement (e.g., 3:6 gives τ = 2⁻³, 2⁻⁴, 2⁻⁵, 2⁻⁶). Used by :temporal test\nNx_fixed: Number of elements per dimension (Ny = Nx assumed). Used by :temporal test\ninput_data: PDE system configuration struct (must contain pmin and pmax for domain bounds)\n\nReturns\n\nNamedTuple with fields:\n\ntest_info: Description of the test performed\nNx: Vector of grid sizes used\nh: Vector of element diameters h = √(Δx² + Δy²)\nτ: Vector of time steps used\nerrors: Named tuple of L∞(L²) error norms for wave and acoustic fields (v=velocity, d=displacement, r=acoustic position, z=acoustic velocity)\nrates: Named tuple of convergence rates for each field\n\nExamples\n\n# Coupled space-time convergence with τ = h\nresults = convergence_test(:coupled, Nx_exp_range=3:6)\n\n# Spatial convergence with fixed time step\nresults = convergence_test(:spatial, Nx_exp_range=3:6, τ_fixed=2^(-7))\n\n# Temporal convergence with fixed spatial grid\nresults = convergence_test(:temporal, τ_exp_range=3:6, Nx_fixed=2^7)\n\n# Display results\nprint_convergence_table(results)\n\nExtended help\n\nThe element diameter h is computed for uniform rectangular meshes as the diagonal length of each element: h = √(Δx² + Δy²), where Δx and Δy are element dimensions in x and y directions. The implementation assumes uniform mesh refinement with Ny = Nx elements per dimension, though the physical domain can be non-square (shape determined by pmin and pmax in input_data).\n\nFor the :coupled test, the relationship τ = h is specifically designed for linear Lagrange finite elements.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.print_convergence_table-Tuple{Any}","page":"API Reference","title":"WaveAcoustics.print_convergence_table","text":"print_convergence_table(results)\n\nDisplay formatted convergence table from convergence test results.\n\nArguments\n\nresults: NamedTuple returned by convergence_test containing test results\n\nExamples\n\nresults = convergence_test(:coupled, Nx_exp_range=3:6)\nprint_convergence_table(results)\n\n\n\n\n\n","category":"method"}]
}
