var documenterSearchIndex = {"docs":
[{"location":"theory/model/#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"theory/model/#Strong-Formulation","page":"Model","title":"Strong Formulation","text":"We seek functions u and z satisfying the following system of equations:\n\nbeginalignlabelpdemdl\nbeginaligned\n u^primeprime(xt) \n- alpha(t)Delta u(xt) \n+ fbig(u(xt)big) \n= f_1(xt)\nquad(xt)inOmegatimes(0+infty)\n5pt\n q_1 z^primeprime(xt)\n+ q_2 z^prime(xt)\n+ q_3 z(xt)\n+ q_4 u^prime(xt)\n= f_2(xt)\nquad(xt)inGamma_1times(0+infty)\n5pt\n fracpartial upartialnu(xt)\n= z^prime(xt)\n- gbig(xu^prime(xt)big)\nquad(xt)inGamma_1times(0+infty)\n5pt\n u(xt) = 0quad (xt)inGamma_0times(0+infty)\nendaligned\nendalign\n\nwith initial conditions\n\nbeginalignlabelpdemdlinitial_condition\nbeginaligned\n u(x0) = u_0(x)quad u^prime(x0)=v_0(x)quad xinOmega\n\n z(x0) = z_0(x)quad\n  z^prime(x0) = r_0(x) equiv fracpartial u_0partialnu(x) + gbig(xv_0(x)big)quad xinGamma_1\nendaligned\nendalign\n\nwhere Omega is a bounded open subset of mathbbR^n, ngeq 2, with smooth boundary Gamma=Gamma_0cupGamma_1 and disjoint Gamma_0, Gamma_1.\n\nExistence and uniqueness results for particular cases of \\eqref{pde:mdl}-\\eqref{pde:mdl:initial_condition} can be found in Alcântara et al. (2025) \"Numerical analysis for nonlinear wave equations with boundary conditions: Dirichlet, Acoustics and Impenetrability\", Applied Mathematics and Computation, 484, 129009, https://doi.org/10.1016/j.amc.2024.129009.","category":"section"},{"location":"theory/model/#Weak-Formulation","page":"Model","title":"Weak Formulation","text":"We seek functions u(t)in H_Gamma_0^1(Omega) and z(t)in L^2(Gamma_1) such that\n\nbeginalign\nlabelpdevariational_form\nbeginaligned\n big(varphiu^primeprime(t)big)\n+ alpha(t)Big\n    big(nablavarphinabla u(t)big)\n  - big(varphiz^prime(t))_Gamma_1\n  + big(varphigbig(u^prime(t)big)big)_Gamma_1Big\n+ big(varphifbig(u(t)big)big) \n= big(varphif_1(t)big)\nquadforallvarphiin H_Gamma_0^1(Omega)\n\n big(phiq_1z^primeprime(t)\n+ q_2z^prime(t)\n+ q_3z(t)\n+ q_4u^prime(t)big)_Gamma_1\n= big(phif_2(t)big)_Gamma_1\nquadforallphiin L^2(Gamma_1)\nendaligned\nendalign\n\nwith  u(0)=u_0,  u^prime(0)=v_0,  z(0)=z_0, and  z^prime(0) = r_0 equiv fracpartial u_0partialnu + g(v_0). \n\nWe consider  H_Gamma_0^1(Omega) =  v in H^1(Omega) v_Gamma_0 = 0   and the inner products and norms in L^2(Omega) and L^2(Gamma_1) by\n\n(cdot cdot)quad\n(cdot cdot)_Gamma_1quad\ncdotquad\ncdot_Gamma_1\n\nBy introducing the auxiliary variables v(t)=u^prime(t) and r(t)=z^prime(t), we obtain the equivalent first-order system: find functions u(t)v(t)in H_Gamma_0^1(Omega) and z(t)r(t)in L^2(Gamma_1) such that\n\nbeginalign\nlabelpdevariational_form_opt2\nbeginaligned\n big(varphiv^prime(t)big)\n+ alpha(t)Big\n    big(nablavarphinabla u(t)big)\n  - big(varphir(t)big)_Gamma_1\n  + big(varphigbig(v(t)big)big)_Gamma_1Big\n+ big(varphifbig(u(t)big)big) \n= big(varphif_1(t)big)\nquadforallvarphiin H_Gamma_0^1(Omega)\n\n big(phiq_1r^prime(t)\n+ q_2r(t)\n+ q_3z(t)\n+ q_4v(t)big)_Gamma_1\n= big(phif_2(t)big)_Gamma_1\nquadforallphiin L^2(Gamma_1)\n\n u^prime(t)=v(t)quad z^prime(t)=r(t)\nendaligned\nendalign\n\nwith initial conditions u(0)=u_0,  v(0)=v_0,  z(0)=z_0, and  r(0) = r_0 equiv fracpartial u_0partialnu + g(v_0).","category":"section"},{"location":"methods/method2/#Scheme-2","page":"Scheme 2","title":"Scheme 2","text":"The second scheme is defined using the linearized Crank-Nicolson Galerkin method, which consists of finding U^n V^n in mathcalV_m_1 and Z^n R^n in mathcalV_m_2 such that\n\nbeginalign\nlabeldefapprox2\nbeginaligned\n big(varphibarpartialV^nbig)\n+ alpha(t_n-frac12)Big\n    big(nablavarphinablawidehatU^nbig)\n  - big(varphiwidehatR^n)_Gamma_1\n  + big(varphig(V^ast n)big)_Gamma_1Big\n+ big(varphif(U^ast n)big) \n= big(varphif_1(t_n-frac12big)\nquadforallvarphiin mathcalV_m_1\n\n big(phiq_1barpartialR^n\n+ q_2widehatR^n\n+ q_3widehatZ^n\n+ q_4V^ast nbig)_Gamma_1\n= big(phif_2(t_n-frac12)big)_Gamma_1\nquadforallphiin mathcalV_m_2\n\n \nbarpartialU^n = widehatV^nquad \nbarpartialZ^n = widehatR^n\nendaligned\nendalign\n\nfor n = text1012ldots, with U^0 V^0 in mathcalV_m_1 and Z^0 R^0 in mathcalV_m_2 given as approximations of the initial solutions u_0 v_0 z_0, and r_0.\n\ndetails: Note\nThe first two time steps in \\eqref{def:approx2} constitute a single-step predictor-corrector initialization.\nIn the prediction step (case n=text10), temporary approximations U^text10, V^text10, Z^text10, and R^text10 at t_1 are computed using the initial solution U^0, V^0, Z^0, and R^0.    \nIn the correction step (case n=1), the temporary approximations from the prediction step, together with the initial solutions, are used to obtain the definitive approximations U^1, V^1, Z^1, and R^1.\nFor n geq 2,  the approximations are generated using information from the two previous time steps at the nonlinear terms and the coupling term in the acoustic equation.\nAt each time step, two independent linear systems are solved, as a result of choices that lead to decoupling the second equation and linearization of the nonlinear terms.\n\ndetails: Notation\nIn addition to the operators  displaystylebarpartialw^n=fracw^n - w^n-1tau and  displaystylewidehatw^n = fracw^n + w^n-12, considerbarpartialw^text10 = fracw^text10 - w^0tauquad\nwidehatw^text10 = fracw^text10 + w^02\nquadtextandquad\nw^*n = \nbegincasesdisplaystyle\nw^0                              textif  n = text10\n10pt displaystyle\nfracw^text10+w^02  textif  n = 1\n10pt displaystyle\nfrac3w^n-1-w^n-22       textif  n geq 2\nendcases","category":"section"},{"location":"methods/method2/#Matrix-formulation","page":"Scheme 2","title":"Matrix formulation","text":"Representing the approximate solutions in terms of the basis functions,\n\nU^n = sum_j=1^m_1 d_j^nvarphi_j\nV^n = sum_j=1^m_1 v_j^nvarphi_j\nZ^n = sum_j=1^m_2 z_j^nphi_j\nR^n = sum_j=1^m_2 r_j^nphi_j\n\nand choosing test functions varphi=varphi_i for i = 1 ldots m_1 and phi=phi_i for i = 1 ldots m_2, we obtain the system\n\nbeginalign\nlabeldefapprox2mat_form\nbeginaligned\n M^m_1times m_1barpartialv^n\n+ alpha(t_n-frac12)Big  \n    K^m_1times m_1widehatd^n\n  - M^m_1times m_2widehatr^n\n  + G^m_1(v^ast n)Big\n+ F^m_1(d^ast n)\n= mathcalF_1^m_1(t_n-frac12)\n\n M^m_2times m_2big\n  q_1barpartialr^n\n+ q_2widehatr^n\n+ q_3widehatz^n\n+ q_4M^m_2times m_1v^ast n\n= mathcalF_2^m_2(t_n-frac12)\n\n barpartiald^n = widehatv^nquad\nbarpartialz^n = widehatr^n\nendaligned\nendalign","category":"section"},{"location":"methods/method2/#Linear-system","page":"Scheme 2","title":"Linear system","text":"Using d^n = d^n-1 + fractau2(v^n+v^n-1) and z^n = z^n-1 + fractau2(r^n+r^n-1) into system \\eqref{def:approx2:mat_form} yields\n\nbeginalign*\nlabeldefapprox2mat_form_opt2\nbeginaligned\n(q_1+fractau2q_2+fractau^24q_3) M^m_2times m_2 r^n\n=\n(q_1-fractau2q_2-fractau^24q_3) M^m_2times m_2 r^n-1\n-tau q_3 M^m_2times m_2 z^n-1\n\n-tau q_4 M^m_2times m_1 v^ast n\n+ taumathcalF_2^m_2(t_n-frac12)\n10pt\nBig\n  M^m_1times m_1 + fractau^2alpha^n-frac124K^m_1times m_1\nBig v^n\n=\n  M^m_1times m_1v^n-1\n\n - taualpha^n-frac12Big\nK^m_1times m_1Big(fractau4v^n-1+d^n-1Big)\n- M^m_1times m_2widehatr^n\n+ G^m_1(v^*n)\nBig\n\n - tau F^m_1(d^*n)\n+ taumathcalF_1^m_1(t_n-frac12)\nendaligned\nendalign*\n\ndetails: Note\nThe computation of r^n can be simplified by multiplying both sides by the inverse of (q_1+fractau2q_2+fractau^24q_3) M^m_2times m_2. Furthermore, for the domain considered in the algorithm implementation, M^m_2times m_1v^ast nequiv M^m_2times m_2v^ast n1m_2 holds, yieldingr^n \n= fracq_1 - fractau2q_2 \n- fractau^24q_3q_1+fractau2q_2 + fractau^24q_3 r^n-1\n- fractau q_3q_1 + fractau2q_2 + fractau^24q_3 z^n-1\n- fractau q_4q_1 + fractau2q_2 + fractau^24q_3 v^ast n1m_2\n+ s^nwhere s^n is obtained fromM^m_2times m_2 s^n = fractauq_1 + fractau2q_2 + fractau^24q_3 mathcalF_2^m_2(t_n-frac12)","category":"section"},{"location":"examples/example2/#Example-2","page":"Example 2","title":"Example 2","text":"","category":"section"},{"location":"examples/example2/#Spatial-refinement-only-(fixed-τ)","page":"Example 2","title":"Spatial refinement only (fixed τ)","text":"julia> results = convergence_test_spatial(\n           input_data=example2_manufactured(), \n           solver=CrankNicolsonLinearized(), \n           Nx_exp_range=3:6, \n           τ_fixed=2^(-12)\n       )\njulia> print_convergence_table(results)\n==============================================================================================================\nSpatial convergence (τ = 0.000244140625 fixed) with CrankNicolsonLinearized\n==============================================================================================================\n   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z\n--------------------------------------------------------------------------------------------------------------\n    8     -2.50   -12.00    4.61e-03    0.000    1.11e-02    0.000    5.07e-03    0.000    6.57e-03    0.000\n   16     -3.50   -12.00    1.17e-03    1.984    2.77e-03    2.006    1.23e-03    2.045    1.61e-03    2.025\n   32     -4.50   -12.00    2.93e-04    1.992    6.90e-04    2.002    3.03e-04    2.017    4.01e-04    2.007\n   64     -5.50   -12.00    7.35e-05    1.994    1.72e-04    2.002    7.56e-05    2.006    1.00e-04    2.002\n==============================================================================================================","category":"section"},{"location":"examples/example1/#Example-1","page":"Example 1","title":"Example 1","text":"","category":"section"},{"location":"examples/example1/#Coupled-space-time-refinement-(τ-h)","page":"Example 1","title":"Coupled space-time refinement (τ = h)","text":"julia> results = convergence_test_coupled(\n           input_data=example1_manufactured(), \n           solver=CrankNicolson(), \n           Nx_exp_range=3:6\n       )\njulia> print_convergence_table(results)\n==============================================================================================================\nCoupled space-time convergence (τ = h) with CrankNicolson\n==============================================================================================================\n   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z\n--------------------------------------------------------------------------------------------------------------\n    8     -2.50    -2.50    3.09e-03    0.000    1.15e-02    0.000    1.38e-02    0.000    1.01e-02    0.000\n   16     -3.50    -3.50    7.68e-04    2.009    2.89e-03    1.994    3.64e-03    1.923    2.79e-03    1.862\n   32     -4.50    -4.50    1.96e-04    1.970    7.20e-04    2.004    8.99e-04    2.020    6.92e-04    2.011\n   64     -5.50    -5.50    5.19e-05    1.916    1.81e-04    1.995    2.28e-04    1.977    1.78e-04    1.962\n==============================================================================================================\n","category":"section"},{"location":"examples/example1/#Spatial-refinement-only-(fixed-τ)","page":"Example 1","title":"Spatial refinement only (fixed τ)","text":"julia> results = convergence_test_spatial(\n           input_data=example1_manufactured(), \n           solver=CrankNicolson(), \n           Nx_exp_range=3:6, \n           τ_fixed=2^(-7)\n       )\njulia> print_convergence_table(results)\n==============================================================================================================\nSpatial convergence (τ = 0.0078125 fixed) with CrankNicolson\n==============================================================================================================\n   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z\n--------------------------------------------------------------------------------------------------------------\n    8     -2.50    -7.00    4.68e-03    0.000    1.12e-02    0.000    1.50e-02    0.000    1.14e-02    0.000\n   16     -3.50    -7.00    1.18e-03    1.990    2.80e-03    2.005    3.61e-03    2.057    2.79e-03    2.036\n   32     -4.50    -7.00    2.90e-04    2.020    7.00e-04    2.001    8.88e-04    2.022    6.92e-04    2.012\n   64     -5.50    -7.00    6.77e-05    2.101    1.75e-04    1.997    2.21e-04    2.007    1.73e-04    2.003\n==============================================================================================================\n","category":"section"},{"location":"examples/example1/#Temporal-refinement-only-(fixed-h)","page":"Example 1","title":"Temporal refinement only (fixed h)","text":"julia> results = convergence_test_temporal(\n           input_data=example1_manufactured(), \n           solver=CrankNicolson(), \n           τ_exp_range=3:6, \n           Nx_fixed=256\n       )\njulia> print_convergence_table(results)\n==============================================================================================================\nTemporal convergence (Nx = 256, h ≈ 0.005524 fixed) with CrankNicolson\n==============================================================================================================\n   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z\n--------------------------------------------------------------------------------------------------------------\n  256     -7.50    -3.00    2.75e-03    0.000    9.13e-04    0.000    1.79e-03    0.000    1.36e-03    0.000\n  256     -7.50    -4.00    6.84e-04    2.008    2.36e-04    1.954    4.50e-04    1.993    3.41e-04    1.996\n  256     -7.50    -5.00    1.69e-04    2.022    6.41e-05    1.877    1.14e-04    1.982    8.62e-05    1.984\n  256     -7.50    -6.00    3.98e-05    2.084    2.18e-05    1.558    3.18e-05    1.841    2.42e-05    1.833\n==============================================================================================================\n\nNote: The deterioration of the optimal convergence rate in the last two refinements indicates that the spatial discretization requires further refinement to maintain temporal accuracy.","category":"section"},{"location":"methods/method1/#Scheme-1","page":"Scheme 1","title":"Scheme 1","text":"We first present a numerical scheme based on the Crank-Nicolson Galerkin method, which consists of finding U^n V^n in mathcalV_m_1 and Z^n R^n in mathcalV_m_2 such that\n\nbeginalign\nlabeldefapprox1\nbeginaligned\n big(varphibarpartialV^nbig)\n+ alpha(t_n-frac12)Big\n    big(nablavarphinablawidehatU^nbig)\n  - big(varphiwidehatR^n)_Gamma_1\n  + big(varphig(widehatV^n)big)_Gamma_1Big\n+ big(varphif(widehatU^n)big) \n= big(varphif_1(t_n-frac12big)\nquadforallvarphiin mathcalV_m_1\n\n big(phiq_1barpartialR^n\n+ q_2widehatR^n\n+ q_3widehatZ^n\n+ q_4widehatV^nbig)_Gamma_1\n= big(phif_2(t_n-frac12)big)_Gamma_1\nquadforallphiin mathcalV_m_2\n\n \nbarpartialU^n = widehatV^nquad \nbarpartialZ^n = widehatR^n\nendaligned\nendalign\n\nwith U^0 V^0 in mathcalV_m_1 and Z^0 R^0 in mathcalV_m_2 given as approximations of the initial solutions u_0 v_0 z_0, and r_0.\n\ndetails: Notation\nmathcalV_m_1 subset H_Gamma_0^1(Omega): Subspace of dimension m_1 with basis varphi_j_j=1^m_1.\nmathcalV_m_2 = mathcalV_m_1_Gamma_1: Subspace of dimension m_2 with basis phi_j_j=1^m_2.\ndisplaystyle w^n=w(t_n)quad barpartialw^n = fracw^n - w^n-1tauapprox w^prime(t_n-frac12)quad widehatw^n = fracw^n + w^n-12approx w(t_n-frac12)where tau denotes the time step, t_n = ntau the discrete times, t_n-frac12 the midpoint of t_n-1t_n, and w an arbitrary time-dependent function.","category":"section"},{"location":"methods/method1/#Matrix-formulation","page":"Scheme 1","title":"Matrix formulation","text":"Representing the approximate solutions in terms of the basis functions,\n\nU^n = sum_j=1^m_1 d_j^nvarphi_j\nV^n = sum_j=1^m_1 v_j^nvarphi_j\nZ^n = sum_j=1^m_2 z_j^nphi_j\nR^n = sum_j=1^m_2 r_j^nphi_j\n\nand choosing test functions varphi=varphi_i for i = 1 ldots m_1 and phi=phi_i for i = 1 ldots m_2, we obtain the system\n\nbeginalign\nlabeldefapprox1mat_form\nbeginaligned\n M^m_1times m_1barpartialv^n\n+ alpha(t_n-frac12)Big  \n    K^m_1times m_1widehatd^n\n  - M^m_1times m_2widehatr^n\n  + G^m_1(widehatv^n)Big\n+ F^m_1(widehatd^n)\n= mathcalF_1^m_1(t_n-frac12)\n\n M^m_2times m_2big\n  q_1barpartialr^n\n+ q_2widehatr^n\n+ q_3widehatz^n\n+ q_4M^m_2times m_1widehatv^n\n= mathcalF_2^m_2(t_n-frac12)\n\n barpartiald^n = widehatv^nquad\nbarpartialz^n = widehatr^n\nendaligned\nendalign\n\ndetails: Matrix and vector definitions\nbeginaligned\n\nM^m_1times m_1_ij = (varphi_ivarphi_j)quad \nM^m_1times m_2_ij = (varphi_iphi_j)_Gamma_1quad \nM^m_2times m_1_ij = (phi_ivarphi_j)_Gamma_1quad \nM^m_2times m_2_ij = (phi_iphi_j)_Gamma_1\n5pt\n\nK^m_1times m_1_ij = (nablavarphi_inablavarphi_j)quad\nmathcalF_1^m_1(t)_i = big(varphi_if_1(t)big)quad\nmathcalF_2^m_2(t)_i = big(phi_if_2(t)big)_Gamma_1\n5pt\n\nG^m_1_i(widehatv^n) \n= big(varphi_ig(widehatV^n)big)_Gamma_1\nequivint_Gamma_1varphi_i(x)gBig(xsum_ell=1^m_1widehatv_ell^nvarphi_ell(x)Big)dGamma\n5pt\n\nF_i^m_1(widehatd^n) \n= big(varphi_if(widehatU^n)big)\nequivint_Omegavarphi_i(x)fBig(sum_ell=1^m_1widehatd_ell^nvarphi_ell(x)Big)dx\nendaligned","category":"section"},{"location":"methods/method1/#Nonlinear-system","page":"Scheme 1","title":"Nonlinear system","text":"Using d^n = d^n-1 + fractau2(v^n+v^n-1) and z^n = z^n-1 + fractau2(r^n+r^n-1) into system \\eqref{def:approx1:mat_form} yields\n\nlabelprob1nonlinear_system\nbeginaligned\nQ^(m_1+m_2)times(m_1+m_2)\nbeginbmatrix\n v^n 5pt\n r^n\nendbmatrix\n+ \nbeginbmatrix\n taualpha(t_n-frac12)\n G^m_1big(fracv^n+v^n-12big) \n + tau F^m_1big(fractau4v^n+fractau4v^n-1+d^n-1big) 5pt\n 0^m_2\nendbmatrix\n-\nbeginbmatrix\nL^m_1\nL^m_2\nendbmatrix\n= 0\nendaligned\n\nwhich can be reformulated as the problem of finding XinmathbbR^m_1+m_2, where X = beginbmatrixv^nr^nendbmatrix, such that\n\nH(X)=0\n\nWe employ Newton's method to solve this nonlinear system. Taking X_0=v^n-1r^n-1 as the initial guess, Newton's method generates the sequence X_kappa+1= X_kappa + S_kappa, where S_kappa is obtained by solving the linear system\n\nJH(X_kappa) S_kappa = -H(X_kappa)\n\nand JH(X_kappa) denotes the Jacobian matrix of H evaluated at X_kappa.\n\ndetails:  Jacobian matrix calculation\nInitially, note that:H_i(X) = sum_ell=1^m_1+m_2Q_iellX_ell\n+ \nbegincases\ntaualpha(t_n-frac12)\nG_i^m_1big(fracX1m_1+v^n-12big) \n+ tau F_i^m_1big(fractau4X1m_1+fractau4v^n-1+d^n-1big)\n- L_i^m_1 \n textif  iin1 ldots m_1\n\n-L_i^m_2 \n textif  iinm_1+1 ldots m_1+m_2\nendcasesIn this way,fracpartial H_ipartial X_j(X) \n= Q_ij \n+\nbegincases\ntaualpha(t_n-frac12)\nfracpartialpartial X_jG_i^m_1big(fracX1m_1+v^n-12big) \n+ tau fracpartialpartial X_jF_i^m_1big(fractau4X1m_1+fractau4v^n-1+d^n-1big)\n textif  iin1 ldots m_1\n\n0\n textif  iinm_1+1 ldots m_1+m_2\nendcaseswhereG_i^m_1(v) \n= int_Gamma_1varphi_i(x)gbig(xsum_ell=1^m_1v_ellvarphi_ell(x)big)dGamma\n\nRightarrow\n\nfracpartialpartial X_j G_i^m_1big(fracX1m_1+v^n-12big)\n= frac12int_Gamma_1varphi_i(x)varphi_j(x)fracpartial gpartial sbig(xsum_ell=1^m_1fracX_ell+v_ell^n-12varphi_ell(x)big)dGammaandF_i^m_1(d) \n= \nint_Omegavarphi_i(x)fBig(sum_ell=1^m_1d_ellvarphi_ell(x)Big)dx\n\nRightarrow\n\nfracpartialpartial X_jF_i^m_1big(fractau4X1m_1+fractau4v^n-1+d^n-1big)\n= \nfractau4int_Omegavarphi_i(x)varphi_j(x)f^primeBig(sum_ell=1^m_1\nbigfractau4X_ell+fractau4v_ell^n-1+d_ell^n-1big\nvarphi_ell(x)Big)dxConsequently, the Jacobian matrix can be expressed as:JH(X) \n= Q\n+ \nbeginbmatrix\nBig\n  fractau2alpha(t_n-frac12) JGbig(fracX1m_1+v^n-12big)\n+ fractau^24 JFbig(fractau4X1m_1+fractau4v^n-1+d^n-1big)\nBig^m_1times m_1\n 0^m_1times m_2\n\n0^m_2times m_1  0^m_2times m_2\nendbmatrix\n\ndetails: Matrix and vector definitions\nbeginaligned\nQ^(m_1+m_2)times(m_1+m_2) =\nbeginbmatrix\n  M^m_1times m_1 + fractau^2alpha(t_n-frac12)4K^m_1times m_1 \n-fractaualpha(t_n-frac12)2M^m_1times m_2  \n5pt\n  fractau2q_4M^m_2times m_1\n (q_1 + fractau2q_2 + fractau^24q_3)M^m_2times m_2\nendbmatrix\n10pt\nL^m_1 = \nM^m_1times m_1v^n-1\n- taualpha(t_n-frac12) K^m_1times m_1Big(fractau4v^n-1+d^n-1Big)\n+ fractau2alpha(t_n-frac12)M^m_1times m_2r^n-1\n+ taumathcalF_1^m_1(t_n-frac12)\n10pt\nL^m_2 =\nM^m_2times m_2Big\n  (q_1 - fractau2q_2 - fractau^24q_3)r^n-1\n  - tau q_3 z^n-1\n  Big\n- fractau2q_4M^m_2times m_1v^n-1\n+ taumathcalF_2^m_2(t_n-frac12)\n10pt\n JG_ij(v) \n= \nint_Gamma_1varphi_i(x)varphi_j(x)fracpartial gpartial sbig(xsum_ell=1^m_1v_ellvarphi_ell(x)big)dGamma\n5pt\n JF_ij(d)\n=\nint_Omegavarphi_i(x)varphi_j(x)f^primeBig(sum_ell=1^m_1d_ellvarphi_ell(x)Big)dx\nendaligned","category":"section"},{"location":"#WaveAcoustics.jl","page":"Home","title":"WaveAcoustics.jl","text":"Welcome to WaveAcoustics.jl documentation!","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This package provides numerical solutions to a wave acoustics PDE systems using the finite element method for spatial discretization and finite difference methods for temporal discretization. \n\nThis package is under active development as a learning project in Julia.","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"theory/model.md\", \"methods/method1.md\",\"methods/method2.md\", \"examples/example1.md\",\"examples/example2.md\", \"api/api.md\"]\nDepth = 2","category":"section"},{"location":"api/api/#API-Reference","page":"API Reference","title":"API Reference","text":"Documentation for WaveAcoustics.\n\n","category":"section"},{"location":"api/api/#Mesh","page":"API Reference","title":"Mesh","text":"","category":"section"},{"location":"api/api/#Finite-Element-Families","page":"API Reference","title":"Finite Element Families","text":"","category":"section"},{"location":"api/api/#Basis-Functions","page":"API Reference","title":"Basis Functions","text":"","category":"section"},{"location":"api/api/#1D-Lagrange-Elements","page":"API Reference","title":"1D Lagrange Elements","text":"","category":"section"},{"location":"api/api/#2D-Lagrange-Elements","page":"API Reference","title":"2D Lagrange Elements","text":"","category":"section"},{"location":"api/api/#1D-Hermite-Elements","page":"API Reference","title":"1D Hermite Elements","text":"","category":"section"},{"location":"api/api/#2D-Hermite-Elements","page":"API Reference","title":"2D Hermite Elements","text":"","category":"section"},{"location":"api/api/#Boundary-Conditions","page":"API Reference","title":"Boundary Conditions","text":"","category":"section"},{"location":"api/api/#DOF-Map","page":"API Reference","title":"DOF Map","text":"","category":"section"},{"location":"api/api/#Quadrature-Setup","page":"API Reference","title":"Quadrature Setup","text":"","category":"section"},{"location":"api/api/#Assemble-local-matrices","page":"API Reference","title":"Assemble local matrices","text":"","category":"section"},{"location":"api/api/#Assemble-global-matrices","page":"API Reference","title":"Assemble global matrices","text":"","category":"section"},{"location":"api/api/#Assemble-global-vectors","page":"API Reference","title":"Assemble global vectors","text":"","category":"section"},{"location":"api/api/#Initial-Solution","page":"API Reference","title":"Initial Solution","text":"","category":"section"},{"location":"api/api/#PDE-Input-Data","page":"API Reference","title":"PDE Input Data","text":"","category":"section"},{"location":"api/api/#PDE-Solve","page":"API Reference","title":"PDE Solve","text":"","category":"section"},{"location":"api/api/#EDO-Solve","page":"API Reference","title":"EDO Solve","text":"","category":"section"},{"location":"api/api/#Crank-Nicolson-Method","page":"API Reference","title":"Crank-Nicolson Method","text":"","category":"section"},{"location":"api/api/#Linearized-Crank-Nicolson-Method","page":"API Reference","title":"Linearized Crank-Nicolson Method","text":"","category":"section"},{"location":"api/api/#Error-norms","page":"API Reference","title":"Error norms","text":"","category":"section"},{"location":"api/api/#Convergence-test","page":"API Reference","title":"Convergence test","text":"","category":"section"},{"location":"api/api/#WaveAcoustics.AbstractMesh","page":"API Reference","title":"WaveAcoustics.AbstractMesh","text":"AbstractMesh{Dim}\n\nAbstract supertype for meshes in dimension Dim.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.CartesianMesh","page":"API Reference","title":"WaveAcoustics.CartesianMesh","text":"CartesianMesh{Dim,I} <: AbstractMesh{Dim}\n\nUniform Cartesian mesh in dimension Dim with integer type I.\n\nFields\n\npmin::NTuple{Dim,Float64}: Domain lower corner\npmax::NTuple{Dim,Float64}: Domain upper corner\nNx::NTuple{Dim,I}: Number of elements per direction\nΔx::NTuple{Dim,Float64}: Element sizes per direction\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.CartesianMesh-Union{Tuple{I}, Tuple{Dim}, Tuple{NTuple{Dim, Float64}, NTuple{Dim, Float64}, NTuple{Dim, I}}} where {Dim, I<:Integer}","page":"API Reference","title":"WaveAcoustics.CartesianMesh","text":"CartesianMesh(pmin, pmax, Nx)\n\nConstruct uniform Cartesian mesh partitioning [pmin, pmax] (1D) or  [pmin[1], pmax[1]] × [pmin[2], pmax[2]] (2D) into Nx elements per direction.\n\nArguments\n\npmin::NTuple{Dim,Float64}: Domain lower corner\npmax::NTuple{Dim,Float64}: Domain upper corner\nNx::NTuple{Dim,I}: Number of elements per direction\n\nExamples\n\njulia> mesh1d = WaveAcoustics.CartesianMesh((0.0,), (1.0,), (10,));\n\njulia> mesh1d.Δx\n(0.1,)\n\njulia> mesh2d = WaveAcoustics.CartesianMesh((0.0, 0.0), (1.0, 2.0), (10, 20));\n\njulia> mesh2d.Δx\n(0.1, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.FEFamily","page":"API Reference","title":"WaveAcoustics.FEFamily","text":"FEFamily\n\nAbstract supertype for finite element families.\n\nConcrete subtypes must specify spatial dimension Dim and polynomial degree Deg.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.Hermite","page":"API Reference","title":"WaveAcoustics.Hermite","text":"Hermite{Dim,Deg} <: FEFamily\n\nHermite finite element of dimension Dim and degree Deg.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.Lagrange","page":"API Reference","title":"WaveAcoustics.Lagrange","text":"Lagrange{Dim,Deg} <: FEFamily\n\nLagrange finite element of dimension Dim and degree Deg.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.num_local_dof","page":"API Reference","title":"WaveAcoustics.num_local_dof","text":"num_local_dof(family::FEFamily)\n\nReturn number of local DOFs for the finite element family.\n\nExamples\n\njulia> WaveAcoustics.num_local_dof(Lagrange{2,3}())\n16\n\njulia> WaveAcoustics.num_local_dof(Hermite{1,3}())\n4\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.polynomial_degree","page":"API Reference","title":"WaveAcoustics.polynomial_degree","text":"polynomial_degree(family::FEFamily)\n\nReturn polynomial degree for the finite element family.\n\nExamples\n\njulia> WaveAcoustics.polynomial_degree(Lagrange{2,3}())\n3\n\njulia> WaveAcoustics.polynomial_degree(Hermite{1,3}())\n3\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Lagrange{1,1}, ξ)\n\nLinear Lagrange basis functions on the reference interval [-1, 1].\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{2,T}: Values of the two basis functions [ϕ₁(ξ), ϕ₂(ξ)]\n\nNode Layout\n\n1 --- 2\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Lagrange{1,1}, ξ)\n\nDerivatives of linear Lagrange basis functions with respect to ξ.\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{2,T}: Derivatives [dϕ₁/dξ, dϕ₂/dξ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Lagrange{1,2}, ξ)\n\nQuadratic Lagrange basis functions on the reference interval [-1, 1].\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{3,T}: Values of the three basis functions [ϕ₁(ξ), ϕ₂(ξ), ϕ₃(ξ)]\n\nNode Layout\n\n1 --- 2 --- 3\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Lagrange{1,2}, ξ)\n\nDerivatives of quadratic Lagrange basis functions with respect to ξ.\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{3,T}: Derivatives [dϕ₁/dξ, dϕ₂/dξ, dϕ₃/dξ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Lagrange{1,3}, ξ)\n\nCubic Lagrange basis functions on the reference interval [-1, 1].\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{4,T}: Values of the four basis functions [ϕ₁(ξ), ϕ₂(ξ), ϕ₃(ξ), ϕ₄(ξ)]\n\nNode Layout\n\n1 --- 2 --- 3 --- 4\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Lagrange{1,3}, ξ)\n\nDerivatives of cubic Lagrange basis functions with respect to ξ.\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{4,T}: Derivatives [dϕ₁/dξ, dϕ₂/dξ, dϕ₃/dξ, dϕ₄/dξ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T<:Real}","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Lagrange{2,Deg}, ξ, η)\n\nTensor-product Lagrange basis functions on the reference square [-1,1] × [-1,1].\n\nArguments\n\nξ::T: First coordinate in the reference element\nη::T: Second coordinate in the reference element\n\nReturns\n\nSVector{(Deg+1)²,T}: Values of all basis functions\n\nNode Layout (Deg = 1)\n\n3 --- 4\n|     |\n1 --- 2\n\nNode Layout (Deg = 2)\n\n7 --- 8 --- 9\n|     |     |\n4 --- 5 --- 6\n|     |     |\n1 --- 2 --- 3\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T<:Real}","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Lagrange{2,Deg}, ξ, η)\n\nDerivatives of tensor-product Lagrange basis functions.\n\nArguments\n\nξ::T: First coordinate in the reference element\nη::T: Second coordinate in the reference element\n\nReturns\n\nTuple (∂ϕ/∂ξ, ∂ϕ/∂η) where:\n∂ϕ/∂ξ::SVector{(Deg+1)²,T}: Derivatives ∂ϕᵢ/∂ξ\n∂ϕ/∂η::SVector{(Deg+1)²,T}: Derivatives ∂ϕᵢ/∂η\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Hermite{1,3}, ξ)\n\nCubic Hermite basis functions on the reference interval [-1, 1].\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{4,T}: Values [H₁(ξ), H₁'(ξ), H₂(ξ), H₂'(ξ)]\n\nNode Layout\n\n1:2 ---- 3:4\n\nEach node has 2 DOFs: (u, du/dξ)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Hermite{1,3}, ξ)\n\nDerivatives of cubic Hermite basis functions with respect to ξ.\n\nArguments\n\nξ::T: Coordinate in the reference element [-1, 1]\n\nReturns\n\nSVector{4,T}: Derivatives [dH₁/dξ, dH₁'/dξ, dH₂/dξ, dH₂'/dξ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions","text":"basis_functions(::Hermite{2,3}, ξ, η)\n\nBicubic Hermite basis functions on the reference square [-1,1] × [-1,1].\n\nArguments\n\nξ::T: First coordinate in the reference element\nη::T: Second coordinate in the reference element\n\nReturns\n\nSVector{16,T}: Values of all 16 basis functions\n\nNode Layout\n\n 9:12 ---- 13:16\n  |          |\n  |          |\n 1:4  ----  5:8\n\nEach corner node has 4 DOFs: (u, ∂u/∂ξ, ∂u/∂η, ∂²u/∂ξ∂η)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T<:Real","page":"API Reference","title":"WaveAcoustics.basis_functions_derivatives","text":"basis_functions_derivatives(::Hermite{2,3}, ξ, η)\n\nDerivatives of Bicubic Hermite basis functions.\n\nArguments\n\nξ::T: First coordinate in the reference element\nη::T: Second coordinate in the reference element\n\nReturns\n\nTuple (∂ϕ/∂ξ, ∂ϕ/∂η) where:\n∂ϕ/∂ξ::SVector{16,T}: Derivatives ∂ϕᵢ/∂ξ\n∂ϕ/∂η::SVector{16,T}: Derivatives ∂ϕᵢ/∂η\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.DirichletSides","page":"API Reference","title":"WaveAcoustics.DirichletSides","text":"DirichletSides\n\nAbstract supertype for domain sides with Dirichlet BCs.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.LeftRight","page":"API Reference","title":"WaveAcoustics.LeftRight","text":"LeftRight <: DirichletSides\n\nDirichlet boundary conditions imposed on the left and right sides of a 1D domain.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.LeftRightBottomTop","page":"API Reference","title":"WaveAcoustics.LeftRightBottomTop","text":"LeftRightBottomTop <: DirichletSides\n\nDirichlet boundary conditions imposed on all four sides (left, right, bottom, and top) of a 2D domain.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.LeftRightTop","page":"API Reference","title":"WaveAcoustics.LeftRightTop","text":"LeftRightTop <: DirichletSides\n\nDirichlet boundary conditions imposed on the left, right, and top sides of a 2D domain.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.DOFMap","page":"API Reference","title":"WaveAcoustics.DOFMap","text":"DOFMap{T <: AbstractVector, I <: Integer}\n\nLocal-to-global DOF mapping with homogeneous Dirichlet BCs enforced on the FE approximation subspace.\n\nFields\n\nEQoLG::T: Element connectivity. EQoLG[e][a] gives global index of local DOF a in element e\nm::I: Number of free DOFs after homogeneous Dirichlet BC enforcement on the FE approximation subspace\n\nIndexing Convention\n\nGlobal functions in the approximation subspace: indices 1, 2, ..., m\nGlobal functions NOT in the approximation subspace: sentinel value m+1\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.DOFMap-Union{Tuple{I}, Tuple{Dim}, Tuple{WaveAcoustics.CartesianMesh{Dim, I}, WaveAcoustics.FEFamily, WaveAcoustics.DirichletSides}} where {Dim, I<:Integer}","page":"API Reference","title":"WaveAcoustics.DOFMap","text":"DOFMap(mesh::CartesianMesh, family::FEFamily, sides::DirichletSides)\n\nConstruct DOF map for given mesh, element family, and Dirichlet boundary conditions.\n\nArguments\n\nmesh: Cartesian mesh\nfamily: Finite element family (e.g., Lagrange{2,3}())\nsides: Dirichlet boundary condition specification (e.g., LeftRight())\n\nReturns\n\nDOFMap containing element connectivity and number of free DOFs.\n\nExamples\n\njulia> mesh = WaveAcoustics.CartesianMesh((0.0,), (1.0,), (4,));\n\njulia> dofmap = WaveAcoustics.DOFMap(mesh, WaveAcoustics.Lagrange{1,1}(), WaveAcoustics.LeftRight());\n\njulia> dofmap.EQoLG\n4-element Vector{StaticArraysCore.SVector{2, Int64}}:\n [4, 1]\n [1, 2]\n [2, 3]\n [3, 4]\n\njulia> dofmap.m\n3\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.apply_EQ!-Union{Tuple{I}, Tuple{Vector{<:StaticArraysCore.SVector}, Vector{<:StaticArraysCore.SVector}, Vector{I}}} where I<:Integer","page":"API Reference","title":"WaveAcoustics.apply_EQ!","text":"apply_EQ!(EQoLG, LG, EQ)\n\nApply equation numbering to local-to-global map (in-place).\n\nTransforms LG (before BCs) into EQoLG (after BCs) using EQ mapping.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.build_EQ","page":"API Reference","title":"WaveAcoustics.build_EQ","text":"build_EQ(Nx, family, sides)\n\nBuild equation numbering array that enforces homogeneous Dirichlet BCs.\n\nReturns\n\nEQ: Array mapping global DOF index (before BCs) to free DOF index (after BCs)\nm: Number of free DOFs\n\nIndexing Convention\n\nGlobal functions in the approximation subspace: indices 1, 2, ..., m\nGlobal functions NOT in the approximation subspace: sentinel value m+1\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.build_LG","page":"API Reference","title":"WaveAcoustics.build_LG","text":"build_LG(mesh, family)\n\nBuild local-to-global DOF map before BC enforcement.\n\nReturns vector LG where LG[e] contains global DOF indices for element e. Uses tensor product ordering: DOFs numbered left-to-right, bottom-to-top.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.QuadratureSetup","page":"API Reference","title":"WaveAcoustics.QuadratureSetup","text":"QuadratureSetup{T<:Real}\n\nPrecomputed quadrature data for finite element assembly using Gauss-Legendre quadrature.\n\nFields\n\nP, W: Quadrature points and weights in [-1,1].\nϕP, W_ϕP, W_ϕPϕP: 1D basis functions and weighted products.\nφP, W_φP, W_φPφP: 2D basis functions and weighted products\nW_∂φ∂ξP, W_∂φ∂ηP: Weighted basis function derivatives\nxP, yP:  Precomputed fixed part of physical quad points: (Δx/2)*(P+1) + xmin, (Δy/2)*(P+1) + ymin\n\nNotes\n\nCurrently specialized for Npg = 4 Gauss–Legendre points per dimension\nCurrently specialized for linear Lagrange basis functions\nFor element at indices (ex, ey), physical quadrature coordinates are:\n\nxeP = @. xP + (ex - 1) * Δx\nyeP = @. yP + (ey - 1) * Δy\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.QuadratureSetup-Union{Tuple{T}, Tuple{Tuple{T, T}, Tuple{T, T}}} where T<:Real","page":"API Reference","title":"WaveAcoustics.QuadratureSetup","text":"QuadratureSetup(Δx, pmin)\n\nConstruct quadrature setup with 4 Gauss-Legendre points per dimension.\n\nArguments\n\nΔx::NTuple{2,T}: Element sizes per direction\npmin::NTuple{2,T}: Domain bottom-left corner (xmin, ymin)\n\nExamples\n\njulia> quad = WaveAcoustics.QuadratureSetup((0.1, 0.2), (0.0, 0.0));\n\njulia> length(quad.xP)\n4\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_local_matrix_DF!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SMatrix{Npg, Npg, <:StaticArraysCore.SMatrix{nb, nb, T}}, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}}} where {T<:AbstractFloat, I<:Integer, nb, Npg, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_local_matrix_DF!","text":"assembly_local_matrix_DF!(DF, f, d, m, eq, W_φPφP, φP)\n\nDFₐᵦ = ∬ φₐ(ξ,η) φᵦ(ξ,η) f(Uₕ(x(ξ,η),y(ξ,η))) dξ dη over reference element Ω = (-1,1)², with Uₕ(x(ξ,η),y(ξ,η)) = Σ d[eq[j]] φⱼ(ξ,η).\n\nArguments\n\nDF::AbstractMatrix{T}: Local matrix (nb × nb), zeroed and filled in-place only in upper triangle\nf::Fun: Callable f(s) → T\nd::AbstractVector{T}: Coefficient vector for Uₕ, length m\nm::I: Number of active DOFs\neq::SVector{nb,I}: Local-to-global DOF mapping for element e (EQoLG[e])\nW_φPφP::SMatrix{Npg,Npg,<:SMatrix{nb,nb,T}}: Precomputed Wᵢ⋅Wⱼ⋅φₐ(Pᵢ,Pⱼ)⋅φᵦ(Pᵢ,Pⱼ) (NO Jacobian, NO scale)\nφP::SMatrix{Npg,Npg,SVector{nb,T}}: Precomputed φ(Pᵢ,Pⱼ)\n\nType Parameters\n\nT: Floating point type\nI: Integer type\nnb: Number of basis functions per element\nNpg: Number of quadrature points per element in each axis direction \nFun: Function type\n\nNotes\n\nScaling factor and Jacobian are NOT applied here\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_local_matrix_DG!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SVector{Npg, T}, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, I<:Integer, nb, Npg, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_local_matrix_DG!","text":"assembly_local_matrix_DG!(DG, ∂ₛg, v, m, eq, xeP, W_ϕPϕP, ϕP)\n\nDGₐᵦ = ∫ ϕₐ(ξ) * ϕᵦ(ξ) * ∂ₛg(x(ξ), Vₕ(x(ξ))) dx over Ω = (-1,1), with Vₕ(x(ξ)) = Σ v[eq[j]] ϕⱼ(ξ).\n\nArguments\n\nDG::AbstractMatrix{T}: Local matrix (nb × nb), zeroed and filled in-place only in upper triangle\n∂ₛg::Fun: Callable ∂ₛg(x, s) → T\nv::AbstractVector{T}: Coefficient vector for Vₕ, length m\nm::I: Number of active DOFs\neq::SVector{nb,I}: Local-to-global DOF mapping for element e (EQoLG[e])\nxeP::SVector{Npg,T}: Physical quadrature points (xᵉ(P) = (Δx/2)*(P + 1) + x_start + (e-1)*Δx)\nquad::QuadratureSetup: Precomputed quadrature data\n\nType Parameters\n\nT: Floating point type\nI: Integer type\nnb: Number of basis functions per element\nNpg: Number of quadrature points per element\nFun: Function type\n\nNotes\n\nScaling factor and Jacobian are NOT applied here\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_local_matrix_ϕxϕ","page":"API Reference","title":"WaveAcoustics.assembly_local_matrix_ϕxϕ","text":"assembly_local_matrix_ϕxϕ(mesh, family)\n\nAssemble the local mass matrix ∫_{Ωₑ} ϕₐᵉ ϕᵦᵉ dx for an arbitrary element Ωₑ.\n\nArguments\n\nmesh::CartesianMesh{Dim}: Uniform Cartesian mesh defining element geometry\nfamily::FEFamily: Finite element family\n\nReturns\n\nSMatrix{N,N}: Local mass matrix where N = num_local_dof(family)\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ","page":"API Reference","title":"WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ","text":"assembly_local_matrix_∇ϕx∇ϕ(mesh, family)\n\nAssemble the local stiffness matrix ∫_{Ωₑ} ∇ϕₐᵉ · ∇ϕᵦᵉ dx for an arbitrary element Ωₑ.\n\nArguments\n\nmesh::CartesianMesh{Dim}: Uniform Cartesian mesh defining element geometry\nfamily::FEFamily: Finite element family\n\nReturns\n\nSMatrix{N,N}: Local stiffness matrix where N = num_local_dof(family)\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{LinearAlgebra.Symmetric{T, <:StaticArraysCore.SMatrix{N, N, T}}, WaveAcoustics.DOFMap{<:AbstractVector, I}}} where {N, T, I<:Integer}","page":"API Reference","title":"WaveAcoustics.assembly_global_matrix","text":"assembly_global_matrix(local_matrix, dof_map) -> Symmetric{T, SparseMatrixCSC{T,I}}\n\nAssemble global symmetric FEM matrix from element-local symmetric matrix. Only stores upper triangle, reducing memory and assembly time.\n\nArguments\n\nlocal_matrix::Symmetric{T, <:SMatrix{N,N,T}}: Symmetric element matrix (N×N)\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\n\nReturns\n\nSymmetric{T, SparseMatrixCSC{T,I}}: Assembled symmetric global matrix (m×m)\n\nAssumptions\n\nAssumes a ≤ b ⇒ ia ≤ jb for all local indices, where ia = EQoLG[e][a] and  jb = EQoLG[e][b]. This condition holds for structured meshes with consistent  left-to-right, bottom-to-top numbering.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, N, T}, WaveAcoustics.DOFMap{<:AbstractVector, I}}} where {N, T, I<:Integer}","page":"API Reference","title":"WaveAcoustics.assembly_global_matrix","text":"assembly_global_matrix(local_matrix, dof_map) -> SparseMatrixCSC\n\nAssemble global FEM matrix from element-local matrix.\n\nArguments\n\nlocal_matrix::SMatrix{N,N,T}: Element matrix (N×N)\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\n\nReturns\n\nSparseMatrixCSC{T,I}: Assembled global matrix (m×m), excluding DOFs > m\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_global_matrix_DF-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, I<:Integer, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_global_matrix_DF","text":"assembly_global_matrix_DF(scale, f, d, mesh, dof_map, quad)\n\nDFᵢⱼ = scale * ∬ φᵢ(x,y) * φⱼ(x,y) * f(Uₕ(x,y)) dx dy over Ω, with Uₕ(x,y) = Σ d[k] φₖ(x,y).\n\nArguments\n\nscale::T: Scaling factor applied to final result\nf::Fun: Callable f(s) → T\nd::AbstractVector{T}: Coefficient vector for Uₕ, length dof_map.m\nmesh::CartesianMesh{2, I}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\nReturns\n\nSymmetric{T, SparseMatrixCSC{T,I}}: Assembled symmetric global matrix (m×m)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_global_matrix_DG-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, I<:Integer, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_global_matrix_DG","text":"assembly_global_matrix_DG(scale, ∂ₛg, v, mesh, dof_map, quad)\n\nDGᵢⱼ = scale * ∫ ϕᵢ(x) * ϕⱼ(x) * ∂ₛg(x, Vₕ(x)) dx over Ω ⊂ ℜ, with Vₕ(x) = Σ v[k] ϕₖ(x).\n\nArguments\n\nscale::T: Scaling factor applied to final result\n∂ₛg::Fun: Callable ∂ₛg(x, v) → T\nv::AbstractVector{T}: Coefficient vector for Vₕ, length dof_map.m\nmesh::CartesianMesh{1,I}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\nReturns\n\nSymmetric{T, SparseMatrixCSC{T,I}}: Assembled symmetric global matrix (m×m)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_nonlinearity_F!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_nonlinearity_F!","text":"assembly_nonlinearity_F!(F, scale, f, d, mesh, dof_map, quad)\n\nFᵢ = scale * ∬ φᵢ(x,y) * f(Uₕ(x,y)) dx dy over Ω, with Uₕ(x,y) = Σ d[j] φⱼ(x,y).\n\nArguments\n\nF::AbstractVector{T}: Global vector (zeroed and filled in-place), length dof_map.m\nscale::T: Scaling factor applied to final result\nf::Fun: Nonlinearity function f(u) returning type T\nd::AbstractVector{T}: Coefficient vector for Uₕ, length dof_map.m\nmesh::CartesianMesh{2}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_nonlinearity_G!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:AbstractFloat, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_nonlinearity_G!","text":"assembly_nonlinearity_G!(G, scale, g, v, mesh, dof_map, quad)\n\nGᵢ = scale * ∫ ϕᵢ(x) * g(x, Vₕ(x)) dx over Ω = (0,1), with Vₕ(x) = Σ v[j] ϕⱼ(x).\n\nArguments\n\nG::AbstractVector{T}: Global vector (zeroed and filled in-place), length dof_map.m\nscale::T: Scaling factor applied to final result\ng::Fun: Callable g(x, v) → scalar\nv::AbstractVector{T}: Coefficient vector for Vₕ, length dof_map.m\nmesh::CartesianMesh{1}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_rhs_1d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg}, StaticArraysCore.SVector{nb, T}, 1, Npg}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}}} where {T<:Real, Npg, nb, I<:Integer, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_rhs_1d!","text":"assembly_rhs_1d!(F, f, scale, W_basisP, mesh, dof_map, xP)\n\nAssemble global RHS vector for 1D FEM by integrating f(x) against basis functions.\n\nArguments\n\nF::AbstractVector{T}: Global RHS vector (modified in-place, length dof_map.m)\nf::Fun: Source function f(x) returning type T\nscale::T: Scaling factor (typically Δx/2 for F[i] = ∫Ω f(x) ϕᵢ(x) dx)\nW_basisP::SVector{Npg,SVector{nb,T}}: Precomputed weighted basis evaluations at quadrature points\nmesh::CartesianMesh{1,I}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nxP::SVector{Npg,T}: Precomputed fixed part of physical quad points: (Δx/2)*(P+1) + x_start\n\nType Parameters\n\nT: Floating point type for computations\nNpg: Number of quadrature points per element\nnb: Number of local basis functions per element\nI: Integer type for mesh indexing\nFun: Function type for source term\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.assembly_rhs_2d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}, StaticArraysCore.SVector{Npg, T}}} where {T<:Real, Npg, nb, I<:Integer, Fun}","page":"API Reference","title":"WaveAcoustics.assembly_rhs_2d!","text":"assembly_rhs_2d!(F, f, scale, W_basisP, mesh, dof_map, xP, yP)\n\nAssemble global RHS vector for 2D FEM by integrating f(x,y) against basis functions.\n\nArguments\n\nF::AbstractVector{T}: Global RHS vector (modified in-place, length dof_map.m)\nf::Fun: Source function f(x,y) returning type T\nscale::T: Scaling factor (typically Δx*Δy/4 for F[i] = ∫Ω f(x,y) φᵢ(x,y) dx dy)\nW_basisP::SMatrix{Npg,Npg,SVector{nb,T}}: Precomputed weighted basis evaluations at quadrature points\nmesh::CartesianMesh{2,I}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nxP::SVector{Npg,T}: Precomputed fixed part of physical quad points: (Δx/2)*(P+1) + x_start\nyP::SVector{Npg,T}: Precomputed fixed part of physical quad points: (Δy/2)*(P+1) + y_start\n\nType Parameters\n\nT: Floating point type for computations\nNpg: Number of quadrature points per element\nnb: Number of local basis functions per element\nI: Integer type for mesh indexing\nFun: Function type for source term\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_r⁰_z⁰!-NTuple{7, Any}","page":"API Reference","title":"WaveAcoustics.compute_r⁰_z⁰!","text":"compute_r⁰_z⁰!(r⁰, z⁰, lhs_mat, input_data, mesh, dof_map, quad)\n\nCompute initial velocity and displacement fields via L2 projection.\n\nArguments\n\nr⁰::AbstractVector: Output vector for initial velocity coefficients (modified in-place, length dof_map.m)\nz⁰::AbstractVector: Output vector for initial displacement coefficients (modified in-place, length dof_map.m)\nlhs_mat: Matrix to be factorized\ninput_data: Structure containing fields r₀, z₀\nmesh::CartesianMesh{1}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_v⁰_d⁰!-NTuple{7, Any}","page":"API Reference","title":"WaveAcoustics.compute_v⁰_d⁰!","text":"compute_v⁰_d⁰!(v⁰, d⁰, lhs_mat, input_data, mesh, dof_map, quad)\n\nCompute initial velocity and displacement fields via H₀¹ projection from gradient data.\n\nArguments\n\nv⁰::AbstractVector: Output vector for initial velocity coefficients (modified in-place, length dof_map.m)\nd⁰::AbstractVector: Output vector for initial displacement coefficients (modified in-place, length dof_map.m)\nlhs_mat: Matrix to be factorized\ninput_data: Structure containing gradient fields ∂ₓv₀, ∂ᵧv₀, ∂ₓu₀, ∂ᵧu₀\nmesh::CartesianMesh{2}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.projection_H01_2d!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{T}, Tuple{AbstractVector{T}, F1, F2, F3, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, AbstractVector{T}, AbstractVector{T}}} where {T, F1, F2, F3}","page":"API Reference","title":"WaveAcoustics.projection_H01_2d!","text":"projection_H01_2d!(uₕ_coefs, ∂ₓu, ∂ᵧu, factorized_lhs_mat, mesh, dof_map, quad, vec₁, vec₂)\n\nCompute the H₀¹ projection of a function onto a finite element subspace given its gradient components.\n\nSolves the weak formulation (∇uₕ, ∇v) = (∇u, ∇v) for all v ∈ Vₕ, where uₕ is the projection and Vₕ is the finite element space.\n\nArguments\n\nuₕ_coefs::AbstractVector{T}: Output vector for FEM coefficients of the projection (modified in-place, length dof_map.m)\n∂ₓu::F1: Partial derivative ∂u/∂x with signature ∂ₓu(x, y) → T\n∂ᵧu::F2: Partial derivative ∂u/∂y with signature ∂ᵧu(x, y) → T\nfactorized_lhs_mat::F3: Factorized matrix (e.g., Cholesky factorization)\nmesh::CartesianMesh{2}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\nvec₁::AbstractVector{T}: Work vector for RHS assembly (modified in-place, length dof_map.m)\nvec₂::AbstractVector{T}: Work vector for RHS assembly (modified in-place, length dof_map.m)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.PDEInputData","page":"API Reference","title":"WaveAcoustics.PDEInputData","text":"PDEInputData{Tα, Tf, Tdf, Tg, T∂ₛg, Tu₀, T∂ₓu₀, T∂ᵧu₀, Tv₀, T∂ₓv₀, T∂ᵧv₀, Tz₀, Tr₀, Tf₁, Tf₂, Tu, Tv, Tz, Tr}\n\nInput data configuration for coupled wave-acoustic PDE system.\n\nMathematical Model\n\nWave equation on rectangular domain Ω = ]xₘᵢₙ, xₘₐₓ[ × ]yₘᵢₙ, yₘₐₓ[:\n\nfrac²ut²(xyt) - α(t)Δu(xyt) + f(u(xyt)) = f₁(xyt)\n\nwith homogeneous boundary conditions on Γ₀ = ∂Ω \\ Γ₁.\n\nAcoustic equation on bottom boundary Γ₁ = {(x, yₘᵢₙ) : x ∈ ]xₘᵢₙ, xₘₐₓ[}:\n\nq₁frac²zt²(xt) + q₂fraczt(xt) + q₃z(xt) + q₄fracut(xyₘᵢₙt) = f₂(xt)\n\nCoupling condition at Γ₁:\n\nfracpartial upartial y(xyₘᵢₙt)\n= fracpartial zpartial t(xt) \n- gleft(x fracpartial upartial t(xyₘᵢₙt)right)\n\nInitial conditions:\n\nbeginaligned\n u(xy0) = u_0(xy) quad fracpartial upartial t(xy0) = v_0(xy) quad (xy) in Omega\n\n z(x0) = z_0(x) quad fracpartial zpartial t(x0) = r_0(x) quad x in xₘᵢₙ xₘₐₓ\nendaligned\n\nFields\n\nDomain Configuration\n\npmin::NTuple{2,Float64}: Bottom-left corner (xₘᵢₙ, yₘᵢₙ)\npmax::NTuple{2,Float64}: Top-right corner (xₘₐₓ, yₘₐₓ)\nt_final::Float64: Final simulation time\n\nPhysical Parameters\n\nq₁::Float64: Acoustic acceleration coefficient\nq₂::Float64: Acoustic velocity coefficient\nq₃::Float64: Acoustic displacement coefficient\nq₄::Float64: Wave-acoustic coupling strength\n\nCoefficient Functions\n\nα::Tα: Time-dependent wave diffusion coefficient α(t)\nf::Tf, df::Tdf: Nonlinear wave term f(s) and derivative f'(s)\ng::Tg, ∂ₛg::T∂ₛg: Nonlinear coupling g(x,s) and s-derivative ∂ₛg(x,s)\n\nWave Initial Conditions (2D functions on Ω)\n\nu₀::Tu₀: Displacement u(x,y,0)\n∂ₓu₀::T∂ₓu₀, ∂ᵧu₀::T∂ᵧu₀: Spatial derivatives of displacement\nv₀::Tv₀: Velocity v(x,y,0) = ∂ₜu(x,y,0)\n∂ₓv₀::T∂ₓv₀, ∂ᵧv₀::T∂ᵧv₀: Spatial derivatives of velocity\n\nAcoustic Initial Conditions (1D functions on Γ₁)\n\nz₀::Tz₀: Acoustic displacement z(x,0)\nr₀::Tr₀: Acoustic velocity r(x,0) = ∂ₜz(x,0)\n\nSource Terms\n\nf₁::Tf₁: Wave source term f₁(x,y,t) on Ω\nf₂::Tf₂: Acoustic source term f₂(x,t) on Γ₁\n\nAnalytical Solutions\n\nFor manufactured solution cases, provide analytical solutions for convergence studies:\n\nu::Tu, v::Tv: Analytical wave solutions u(x,y,t), v(x,y,t)\nz::Tz, r::Tr: Analytical acoustic solutions z(x,t), r(x,t)\n\nFor physical simulations without known solutions, these fields are nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.example1_manufactured","page":"API Reference","title":"WaveAcoustics.example1_manufactured","text":"example1_manufactured(a::Float64=2.4) -> PDEInputData\n\nManufactured solution with oscillatory coupling g(xs) = (1+e^-x^2)(sin(s)+2s).\n\nWave solution: u(xyt) = (x^a-x)(y^a-1)(4+t^2).  Acoustic solution obtained by integrating  z(xt) = -u_y(xy_mint) + g(xu(xy_mint)).\n\nArguments\n\na::Float64=2.4: Smoothness parameter controlling solution regularity.\n\nReturns\n\nPDEInputData with analytical solutions for convergence study.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.example1_zero_source","page":"API Reference","title":"WaveAcoustics.example1_zero_source","text":"example1_zero_source(a::Float64=2.4) -> PDEInputData\n\nSame configuration as example1_manufactured but with f₁ = f₂ = 0. No analytical solution available.\n\nArguments\n\na::Float64=2.4: Smoothness parameter for initial conditions.\n\nReturns\n\nPDEInputData with analytical solutions set to nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.example2_manufactured","page":"API Reference","title":"WaveAcoustics.example2_manufactured","text":"example2_manufactured(a::Float64=2.4) -> PDEInputData\n\nManufactured solution with linear coupling g(xs) = (1+e^-x^2)s.\n\nWave solution: u(xyt) = (x^a-x)(y^a-1)(4+t^2).  Acoustic solution obtained by integrating  z(xt) = -u_y(xy_mint) + g(xu(xy_mint)).\n\nArguments\n\na::Float64=2.4: Smoothness parameter controlling solution regularity\n\nReturns\n\nPDEInputData with analytical solutions for convergence study.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.example2_zero_source","page":"API Reference","title":"WaveAcoustics.example2_zero_source","text":"example2_zero_source(a::Float64=2.4) -> PDEInputData\n\nSame configuration as example2_manufactured but with f₁ = f₂ = 0. No analytical solution available.\n\nArguments\n\na::Float64=2.4: Smoothness parameter for initial conditions.\n\nReturns\n\nPDEInputData with analytical solutions set to nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#WaveAcoustics.pde_solve-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{I}, Tuple{Tuple{I, I}, T, Any}, Tuple{Tuple{I, I}, T, Any, S}, Tuple{Tuple{I, I}, T, Any, S, O}} where {I<:Integer, T<:Real, S<:WaveAcoustics.ODESolver, O<:WaveAcoustics.OutputMode}","page":"API Reference","title":"WaveAcoustics.pde_solve","text":"pde_solve(Nx, τ, input_data)\n\nSolve coupled wave-acoustic PDE system and compute L∞(0,T;L²) errors.\n\nArguments\n\nNx::NTuple{2,Integer}: Number of elements per direction\nτ::Real: Time step size\ninput_data::PDEInputData: Problem configuration with manufactured solution \nsolver::ODESolver: Time integration scheme (default: CrankNicolson())\noutput::OutputMode: Output mode (default: ConvergenceStudy())\nConvergenceStudy() → ConvergenceStudyData with L² errors at each time step\nSolutionHistory() → SolutionHistoryData with displacement snapshots\nEnergyHistory() → EnergyHistoryData with energy evolution\n\nReturns\n\nDepends on output:\n\nConvergenceStudyData{T}: Fields v_errors, d_errors, r_errors, z_errors (each a vector of length nt)\nSolutionHistoryData{T}: Fields d_history (m₁×nt), z_history (m₂×nt), times (length nt)\nEnergyHistoryData{T}: Fields energy, times (each length nt)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.process_solution!-Union{Tuple{T}, Tuple{WaveAcoustics.ConvergenceStudyData, ConvergenceStudy, Integer, T, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T<:AbstractFloat","page":"API Reference","title":"WaveAcoustics.process_solution!","text":"Process solution for convergence study: compute L² errors.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.process_solution!-Union{Tuple{T}, Tuple{WaveAcoustics.EnergyHistoryData, EnergyHistory, Integer, T, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T<:AbstractFloat","page":"API Reference","title":"WaveAcoustics.process_solution!","text":"Process solution for energy history: compute energy functional.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.process_solution!-Union{Tuple{T}, Tuple{WaveAcoustics.SolutionHistoryData, SolutionHistory, Integer, T, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T<:AbstractFloat","page":"API Reference","title":"WaveAcoustics.process_solution!","text":"Process solution for solution history: store current solution.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.solve_ode-Tuple{CrankNicolson, WaveAcoustics.OutputMode, Vararg{Any, 12}}","page":"API Reference","title":"WaveAcoustics.solve_ode","text":"solve_ode(::CrankNicolson, output, v⁰, d⁰, r⁰, z⁰, τ, ...)\n\nCrank-Nicolson time integration for the semi-discrete system.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.solve_ode-Tuple{CrankNicolsonLinearized, WaveAcoustics.OutputMode, Vararg{Any, 12}}","page":"API Reference","title":"WaveAcoustics.solve_ode","text":"solve_ode(::CrankNicolsonLinearized, output, v⁰, d⁰, r⁰, z⁰, τ, ...)\n\nLinearized Crank-Nicolson time integration for the semi-discrete system.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.CNCache","page":"API Reference","title":"WaveAcoustics.CNCache","text":"CNCache{T}\n\nCache structure for Crank-Nicolson solver.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.CNCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T","page":"API Reference","title":"WaveAcoustics.CNCache","text":"CNCache(m₁::Integer, m₂::Integer, ::Type{T}) where T\n\nConstruct cache with all vectors initialized to zero.\n\nArguments\n\nm₁: Number of free DOFs in 2D domain Ω\nm₂: Number of free DOFs on 1D boundary Γ₁  \nT: Element type\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_A₁₁!-Tuple{AbstractMatrix, AbstractMatrix, Real, Real, AbstractMatrix}","page":"API Reference","title":"WaveAcoustics.compute_A₁₁!","text":"compute_A₁₁!(A₁₁, M_m₁xm₁, τ²_4, α_half, K_m₁xm₁)\n\nCompute system matrix A₁₁ = Mm₁×m₁ + (τ²/4)α(tₙ₊₁/₂)Km₁×m₁.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_A₁₂!-Tuple{AbstractMatrix, Real, Real, AbstractMatrix}","page":"API Reference","title":"WaveAcoustics.compute_A₁₂!","text":"compute_A₁₂!(A₁₂, τ_2, α_half, M_m₁xm₂)\n\nCompute system matrix A₁₂ = -(τ/2)α(tₙ₊₁/₂)M_m₁×m₂.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_DHX₁₁!-NTuple{13, Any}","page":"API Reference","title":"WaveAcoustics.compute_DHX₁₁!","text":"compute_DHX₁₁!(DHX₁₁, A₁₁, v̂ⁿ_m₂, d̂ⁿ, input_data, mesh1D, mesh2D,\n               dof_map_m₁, dof_map_m₂, quad, τα_2, τ²_4, m₂)\n\nDHX₁₁ = A₁₁ + (τ²/4)⋅DF(d̂ⁿ) + (τ/2)α(tₙ₋₁/₂)⋅DG(v̂ⁿ_m₂)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_Lm₁!-NTuple{13, Any}","page":"API Reference","title":"WaveAcoustics.compute_Lm₁!","text":"compute_Lm₁!(Lm₁, vⁿ⁻¹, rⁿ⁻¹, vec_d_v, matrices, input_data, mesh2D, dof_map_m₁, quad, τ, t_half, α_half, cache)\n\nLm₁ = M_m₁×m₁⋅vⁿ⁻¹ - τα(tₙ₊₁/₂)K_m₁×m₁⋅(dⁿ⁻¹+(τ/4)⋅vⁿ⁻¹) + (τ/2)α(tₙ₊₁/₂)M_m₁×m₂⋅rⁿ⁻¹ + τF(f₁(tₙ₊₁/₂))\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_Lm₂!-NTuple{15, Any}","page":"API Reference","title":"WaveAcoustics.compute_Lm₂!","text":"compute_Lm₂!(Lm₂, rⁿ⁻¹, zⁿ⁻¹, vⁿ⁻¹, matrices, input_data, mesh1D, dof_map_m₂, quad, τ, t_half, τq₄_2, τq₃, cst_q, cache)\n\nLm₂ = M_m₂×m₂⋅(cst_q⋅rⁿ⁻¹ - τq₃⋅zⁿ⁻¹) - (τ/2)q₄⋅M_m₂×m₁⋅vⁿ⁻¹ + τ⋅F(f₂(tₙ₊₁/₂))\n\nwhere cst_q = q₁ - (τ/2)q₂ - (τ²/4)q₃.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_minusHX!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Any, Any, Any, Any, Any, Any, T, T, T, WaveAcoustics.CNCache{T}}} where T","page":"API Reference","title":"WaveAcoustics.compute_minusHX!","text":"compute_minusHX!(minusHX, vⁿ, v̂ⁿ_m₂, d̂ⁿ, rⁿ, A₁₁, A₂₂, M_m₂xm₂, Lm₁, Lm₂, \n                 input_data, mesh1D, mesh2D, dof_map_m₁, dof_map_m₂, quad, \n                 τ, τq₄_2, α_half, cache)\n\nCompute negative residual -H(X) for Newton's method.\n\nThe residual H(X) represents the nonlinear system:\n\nH(X) = [A₁₁⋅vⁿ - (τ/2)α(tₙ₊₁/₂)M_m₁×m₂⋅rⁿ + τα(tₙ₊₁/₂)G(v̂ⁿ_m₂) + τF(d̂ⁿ) - Lm₁]\n       [(τ/2)q₄⋅M_m₂×m₁⋅vⁿ + A₂₂⋅rⁿ - Lm₂                                    ]\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.crank_nicolson-Union{Tuple{O}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any, O}} where {T<:Real, O<:WaveAcoustics.OutputMode}","page":"API Reference","title":"WaveAcoustics.crank_nicolson","text":"crank_nicolson(v⁰, d⁰, r⁰, z⁰, τ, input_data, mesh1D, mesh2D, \n               dof_map_m₁, dof_map_m₂, quad, matrices, output)\n\nSolve coupled wave-acoustic PDE system using Crank-Nicolson time integration.\n\nArguments\n\nv⁰::AbstractVector{T}: Initial wave velocity in Ω\nd⁰::AbstractVector{T}: Initial wave displacement in Ω\nr⁰::AbstractVector{T}: Initial acoustic velocity on Γ₁\nz⁰::AbstractVector{T}: Initial acoustic displacement on Γ₁\nτ::T: Time step size\ninput_data: Problem configuration with manufactured solution\nmesh1D::CartesianMesh{1}: 1D mesh for boundary Γ₁\nmesh2D::CartesianMesh{2}: 2D mesh for domain Ω\ndof_map_m₁::DOFMap: DOF mapping for 2D finite element space\ndof_map_m₂::DOFMap: DOF mapping for 1D boundary space\nquad::QuadratureSetup: Precomputed quadrature data\nmatrices: Preassembled global matrices\noutput::OutputMode: Output mode (default: ConvergenceStudy())\nConvergenceStudy() → ConvergenceStudyData with L² errors at each time step\nSolutionHistory() → SolutionHistoryData with displacement snapshots\nEnergyHistory() → EnergyHistoryData with energy evolution\n\nReturns\n\nDepends on output:\n\nConvergenceStudyData{T}: Fields v_errors, d_errors, r_errors, z_errors (each a vector of length nt)\nSolutionHistoryData{T}: Fields d_history (m₁×nt), z_history (m₂×nt), times (length nt)\nEnergyHistoryData{T}: Fields energy, times (each length nt)\n\nAlgorithm\n\nUses Crank-Nicolson for time discretization with Newton iteration to handle nonlinearities f(u) and g(x,v).  The method is second-order accurate in time.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.CNLCache","page":"API Reference","title":"WaveAcoustics.CNLCache","text":"CNLCache{T}\n\nCache structure for linearized Crank-Nicolson solver.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/api/#WaveAcoustics.CNLCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T","page":"API Reference","title":"WaveAcoustics.CNLCache","text":"CNLCache(m₁::Integer, m₂::Integer, ::Type{T}) where T\n\nConstruct cache with all vectors initialized to zero.\n\nArguments\n\nm₁: Number of free DOFs in 2D domain Ω\nm₂: Number of free DOFs on 1D boundary Γ₁  \nT: Element type\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_A!-Union{Tuple{S}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, S}, LinearAlgebra.Symmetric{T, S}, T, T, LinearAlgebra.Symmetric{T, S}}} where {T, S<:(SparseArrays.SparseMatrixCSC{T})}","page":"API Reference","title":"WaveAcoustics.compute_A!","text":"compute_A!(A, M_m₁xm₁, τ²_4, α_half, K_m₁xm₁)\n\nCompute system matrix A = M_m₁×m₁ + (τ²/4)α(tₙ₊₁/₂)K_m₁×m₁.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_rⁿ!-Union{Tuple{Ff₂}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Any, Ff₂, T, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, WaveAcoustics.CNLCache}} where {T, Ff₂}","page":"API Reference","title":"WaveAcoustics.compute_rⁿ!","text":"compute_rⁿ!(rⁿ, rⁿ⁻¹, zⁿ⁻¹, v_ast_n, cst, M_m₂xm₂_factorized, f₂, t_half, mesh1D, dof_map_m₂, quad, cache)\n\nCompute rⁿ = cst[1]*rⁿ⁻¹ - cst[2]*zⁿ⁻¹ - cst[3]*v_ast_n + M_m₂xm₂ \\ (cst[4]*F(f₂(tₙ₋₁/₂))).\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_vⁿ!-Union{Tuple{Ff1}, Tuple{Ff}, Tuple{Fg}, Tuple{Fα}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Fα, Fg, Ff, Ff1, T, T, T, T, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any, Any, WaveAcoustics.CNLCache}} where {T, Fα, Fg, Ff, Ff1}","page":"API Reference","title":"WaveAcoustics.compute_vⁿ!","text":"compute_vⁿ!(vⁿ, vⁿ⁻¹, dⁿ⁻¹, rⁿ, rⁿ⁻¹, v_ast_n, d_ast_n, α, g, f, f₁, t_half, τ, τ_4, τ²_4, mesh1D, mesh2D, dof_map_m₁, dof_map_m₂, quad, matrices, A, cache)\n\nAssemble and solve A vⁿ = b, where:\n\nA = M_m₁×m₁ + (τ²/4)α(tₙ₋₁/₂)K_m₁×m₁\nb = M_m₁×m₁ vⁿ⁻¹ - τα(tₙ₋₁/₂)K_m₁×m₁((τ/4)vⁿ⁻¹ + dⁿ⁻¹) + (τ/2)α(tₙ₋₁/₂)M_m₂×m₂(rⁿ + rⁿ⁻¹) - τα(tₙ₋₁/₂)G(v_ast_n) - τF(d_ast_n) + τF(f₁(tₙ₋₁/₂))\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.crank_nicolson_linearized-Union{Tuple{O}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any, O}} where {T<:Real, O<:WaveAcoustics.OutputMode}","page":"API Reference","title":"WaveAcoustics.crank_nicolson_linearized","text":"crank_nicolson_linearized(v⁰, d⁰, r⁰, z⁰, τ, input_data, mesh1D, mesh2D, \n                          dof_map_m₁, dof_map_m₂, quad, matrices, output)\n\nSolve coupled wave-acoustic PDE system using linearized Crank-Nicolson time integration.\n\nArguments\n\nv⁰::AbstractVector{T}: Initial wave velocity in Ω\nd⁰::AbstractVector{T}: Initial wave displacement in Ω\nr⁰::AbstractVector{T}: Initial acoustic velocity on Γ₁\nz⁰::AbstractVector{T}: Initial acoustic displacement on Γ₁\nτ::T: Time step size\ninput_data: Problem configuration with manufactured solution\nmesh1D::CartesianMesh{1}: 1D mesh for boundary Γ₁\nmesh2D::CartesianMesh{2}: 2D mesh for domain Ω\ndof_map_m₁::DOFMap: DOF mapping for 2D finite element space\ndof_map_m₂::DOFMap: DOF mapping for 1D boundary space\nquad::QuadratureSetup: Precomputed quadrature data\nmatrices: Preassembled global matrices\noutput::OutputMode: Output mode (default: ConvergenceStudy())\nConvergenceStudy() → ConvergenceStudyData with L² errors at each time step\nSolutionHistory() → SolutionHistoryData with displacement snapshots\nEnergyHistory() → EnergyHistoryData with energy evolution\n\nReturns\n\nDepends on output:\n\nConvergenceStudyData{T}: Fields v_errors, d_errors, r_errors, z_errors (each a vector of length nt)\nSolutionHistoryData{T}: Fields d_history (m₁×nt), z_history (m₂×nt), times (length nt)\nEnergyHistoryData{T}: Fields energy, times (each length nt)\n\nAlgorithm\n\nImplements second-order accurate linearized Crank-Nicolson scheme. Nonlinear terms  f(u) and g(x,v), along with the coupling term q₄v in the acoustic equation,  are evaluated using values from previous time step(s) to decouple the system and  avoid implicit nonlinear solves.\nTemporal refinement requirement: Preliminary tests suggest the algorithm requires  sufficiently refined time steps for stability. The necessary refinement may be related  to the variation of the boundary nonlinearity g. Further investigation needed.\nNote on validation strategy: During implementation validation, the exact solution  was temporarily substituted for v_ast_n in the nonlinear term g(x,v), which  allowed verification of all other algorithmic components. The current implementation  correctly uses the extrapolated velocity v_ast_n as specified in the algorithm.  Convergence analysis with fixed, well-refined τ demonstrates correct behavior; issues  observed in earlier tests with coupled refinement (h = τ) require further analysis.\n\nExamples\n\nSpatial convergence with τ = 2⁻¹² (well-refined) demonstrates optimal second-order convergence:\n\njulia> results = convergence_test_spatial(input_data=example1_manufactured(), solver=CrankNicolsonLinearized(), τ_fixed=2^(-12));\njulia> print_convergence_table(results)\n==============================================================================================================\nSpatial convergence (τ = 0.000244140625 fixed) with CrankNicolsonLinearized\n==============================================================================================================\n   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z\n--------------------------------------------------------------------------------------------------------------\n    8     -2.50   -12.00    4.68e-03    0.000    1.12e-02    0.000    1.50e-02    0.000    1.14e-02    0.000\n   16     -3.50   -12.00    1.18e-03    1.983    2.80e-03    2.005    3.61e-03    2.057    2.79e-03    2.036\n   32     -4.50   -12.00    2.97e-04    1.994    6.99e-04    2.002    8.88e-04    2.022    6.92e-04    2.012\n   64     -5.50   -12.00    7.44e-05    1.998    1.75e-04    2.001    2.21e-04    2.009    1.72e-04    2.004\n==============================================================================================================\n\nInsufficient temporal refinement (τ = 2⁻¹⁰) leads to algorithm failure for example1_manufactured():\n\njulia> results = convergence_test_spatial(input_data=example1_manufactured(), solver=CrankNicolsonLinearized(), τ_fixed=2^(-10));\njulia> print_convergence_table(results)\n==============================================================================================================\nSpatial convergence (τ = 0.0009765625 fixed) with CrankNicolsonLinearized\n==============================================================================================================\n   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z\n--------------------------------------------------------------------------------------------------------------\n    8     -2.50   -10.00    4.68e-03    0.000    1.12e-02    0.000    1.50e-02    0.000    1.14e-02    0.000\n   16     -3.50   -10.00    1.18e-03    1.983    2.80e-03    2.005    3.61e-03    2.057    2.79e-03    2.036\n   32     -4.50   -10.00    6.73e-02   -5.830    2.15e-03    0.380    4.82e-03   -0.419    2.54e-03    0.138\n   64     -5.50   -10.00         NaN      NaN         NaN      NaN         NaN      NaN         NaN      NaN\n==============================================================================================================\n\nHowever, the same temporal refinement (τ = 2⁻¹⁰) is sufficient for  example2_manufactured(), suggesting sensitivity to the specific form of g:\n\njulia> results = convergence_test_spatial(input_data=example2_manufactured(), solver=CrankNicolsonLinearized(), τ_fixed=2^(-10));\njulia> print_convergence_table(results)\n==============================================================================================================\nSpatial convergence (τ = 0.0009765625 fixed) with CrankNicolsonLinearized\n==============================================================================================================\n   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z\n--------------------------------------------------------------------------------------------------------------\n    8     -2.50   -10.00    4.65e-03    0.000    1.21e-02    0.000    5.05e-03    0.000    6.54e-03    0.000\n   16     -3.50   -10.00    1.16e-03    2.000    3.02e-03    2.003    1.22e-03    2.047    1.61e-03    2.026\n   32     -4.50   -10.00    2.91e-04    1.999    7.55e-04    2.002    3.02e-04    2.018    4.00e-04    2.007\n   64     -5.50   -10.00    7.28e-05    1.999    1.88e-04    2.003    7.50e-05    2.008    9.97e-05    2.002\n==============================================================================================================\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.L2_error_1d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:Real, Fun}","page":"API Reference","title":"WaveAcoustics.L2_error_1d","text":"L2_error_1d(u, uₕ_coefs, mesh, dof_map, quad)\n\nCompute the L2 error norm ||u - uₕ||_L2 between exact and FEM solutions.\n\nArguments\n\nu::F: Exact solution function with signature u(x) → T\nuₕ_coefs::AbstractVector{T}: DOF coefficients of the FEM solution (length = dof_map.m)\nmesh::CartesianMesh{1}: 1D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\nReturns\n\nT: L2 norm ||u - uₕ||_L2\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.L2_error_2d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T<:Real, Fun}","page":"API Reference","title":"WaveAcoustics.L2_error_2d","text":"L2_error_2d(u, uₕ_coefs, mesh, dof_map, quad)\n\nCompute the L2 error norm ||u - uₕ||_L2 between exact and FEM solutions.\n\nArguments\n\nu::F: Exact solution function with signature u(x, y) → T\nuₕ_coefs::AbstractVector{T}: DOF coefficients of the FEM solution (length = dof_map.m)\nmesh::CartesianMesh{2}: 2D Cartesian mesh\ndof_map::DOFMap: DOF mapping with EQoLG connectivity and m free DOFs\nquad::QuadratureSetup: Precomputed quadrature data\n\nReturns\n\nT: L2 norm ||u - uₕ||_L2\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.compute_element_diameter-Union{Tuple{T}, Tuple{I}, Tuple{I, Tuple{T, T}, Tuple{T, T}}} where {I<:Integer, T<:AbstractFloat}","page":"API Reference","title":"WaveAcoustics.compute_element_diameter","text":"compute_element_diameter(Nx, pmin, pmax)\n\nCompute element diameter h = √(Δx² + Δy²) for uniform rectangular mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.convergence_test_coupled-Tuple{}","page":"API Reference","title":"WaveAcoustics.convergence_test_coupled","text":"convergence_test_coupled(;input_data, solver, Nx_exp_range)\n\nPerform coupled space-time convergence test with τ = h.\n\nVaries spatial and temporal discretization together, assuming linear basis functions. Convergence rates are computed as log₂(error{i-1} / errori) between successive refinements.\n\nKeyword Arguments\n\ninput_data: PDE input data (default: example1_manufactured())\nsolver::ODESolver: Time integration method (default: CrankNicolson())\nNx_exp_range: Grid refinement exponents (default: 3:6 → Nx = 8, 16, 32, 64)\n\nReturns\n\nNamedTuple with fields: test_info, Nx, h, τ, errors, rates\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.convergence_test_spatial-Tuple{}","page":"API Reference","title":"WaveAcoustics.convergence_test_spatial","text":"convergence_test_spatial(;input_data, solver, Nx_exp_range, τ_fixed)\n\nPerform spatial convergence test with fixed time step.\n\nVaries mesh size h while keeping temporal discretization τ constant to isolate spatial discretization error.\n\nKeyword Arguments\n\ninput_data: PDE input data (default: example1_manufactured())\nsolver::ODESolver: Time integration method (default: CrankNicolson())\nNx_exp_range: Grid refinement exponents (default: 3:6)\nτ_fixed::Real: Fixed time step (default: 2^(-7))\n\nReturns\n\nNamedTuple with fields: test_info, Nx, h, τ, errors, rates\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.convergence_test_temporal-Tuple{}","page":"API Reference","title":"WaveAcoustics.convergence_test_temporal","text":"convergence_test_temporal(;input_data, solver, τ_exp_range, Nx_fixed)\n\nPerform temporal convergence test with fixed spatial grid.\n\nVaries time step τ while keeping mesh size h constant to isolate temporal discretization error.\n\nKeyword Arguments\n\ninput_data: PDE input data (default: example1_manufactured())\nsolver::ODESolver: Time integration method (default: CrankNicolson())\nτ_exp_range: Time step refinement exponents (default: 3:6 → τ = 2^(-3), ..., 2^(-6))\nNx_fixed::Int: Fixed grid size per dimension (default: 2^8)\n\nReturns\n\nNamedTuple with fields: test_info, Nx, h, τ, errors, rates\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.print_convergence_table-Tuple{Any}","page":"API Reference","title":"WaveAcoustics.print_convergence_table","text":"print_convergence_table(results)\n\nDisplay formatted convergence table from convergence test results.\n\nExamples\n\nresults = convergence_test_coupled()\nprint_convergence_table(results)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#WaveAcoustics.run_convergence_study-Tuple{Any, Any, Any, Any, WaveAcoustics.ODESolver, String}","page":"API Reference","title":"WaveAcoustics.run_convergence_study","text":"run_convergence_study(Nx_values, h_values, τ_values, input_data, solver, test_info)\n\nExecute convergence study computing error norms and convergence rates.\n\nSolves the PDE for each refinement level using the specified solver, computes  L∞(L²) error norms for all fields, and calculates convergence rates as  log₂(error{i-1} / errori) between successive refinements.\n\n\n\n\n\n","category":"method"}]
}
