<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · WaveAcoustics.jl</title><meta name="title" content="API Reference · WaveAcoustics.jl"/><meta property="og:title" content="API Reference · WaveAcoustics.jl"/><meta property="twitter:title" content="API Reference · WaveAcoustics.jl"/><meta name="description" content="Documentation for WaveAcoustics.jl."/><meta property="og:description" content="Documentation for WaveAcoustics.jl."/><meta property="twitter:description" content="Documentation for WaveAcoustics.jl."/><meta property="og:url" content="https://bacarmo.github.io/WaveAcoustics.jl/api/api/"/><meta property="twitter:url" content="https://bacarmo.github.io/WaveAcoustics.jl/api/api/"/><link rel="canonical" href="https://bacarmo.github.io/WaveAcoustics.jl/api/api/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">WaveAcoustics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/model/">Model</a></li><li><span class="tocitem">Approximation Problem</span><ul><li><a class="tocitem" href="../../methods/method1/">Scheme 1</a></li><li><a class="tocitem" href="../../methods/method2/">Scheme 2</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example1/">Example 1</a></li><li><a class="tocitem" href="../../examples/example2/">Example 2</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Mesh"><span>Mesh</span></a></li><li><a class="tocitem" href="#Finite-Element-Families"><span>Finite Element Families</span></a></li><li><a class="tocitem" href="#Basis-Functions"><span>Basis Functions</span></a></li><li><a class="tocitem" href="#Boundary-Conditions"><span>Boundary Conditions</span></a></li><li><a class="tocitem" href="#DOF-Map"><span>DOF Map</span></a></li><li><a class="tocitem" href="#Quadrature-Setup"><span>Quadrature Setup</span></a></li><li><a class="tocitem" href="#Assemble-local-matrices"><span>Assemble local matrices</span></a></li><li><a class="tocitem" href="#Assemble-global-matrices"><span>Assemble global matrices</span></a></li><li><a class="tocitem" href="#Assemble-global-vectors"><span>Assemble global vectors</span></a></li><li><a class="tocitem" href="#Initial-Solution"><span>Initial Solution</span></a></li><li><a class="tocitem" href="#PDE-Input-Data"><span>PDE Input Data</span></a></li><li><a class="tocitem" href="#PDE-Solve"><span>PDE Solve</span></a></li><li><a class="tocitem" href="#EDO-Solve"><span>EDO Solve</span></a></li><li><a class="tocitem" href="#Error-norms"><span>Error norms</span></a></li><li><a class="tocitem" href="#Convergence-test"><span>Convergence test</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bacarmo/WaveAcoustics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/main/docs/src/api/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/bacarmo/WaveAcoustics.jl">WaveAcoustics</a>.</p><ul><li><a href="#WaveAcoustics.AbstractMesh"><code>WaveAcoustics.AbstractMesh</code></a></li><li><a href="#WaveAcoustics.CNCache"><code>WaveAcoustics.CNCache</code></a></li><li><a href="#WaveAcoustics.CNCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T"><code>WaveAcoustics.CNCache</code></a></li><li><a href="#WaveAcoustics.CNLCache"><code>WaveAcoustics.CNLCache</code></a></li><li><a href="#WaveAcoustics.CNLCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T"><code>WaveAcoustics.CNLCache</code></a></li><li><a href="#WaveAcoustics.CartesianMesh-Union{Tuple{I}, Tuple{Dim}, Tuple{NTuple{Dim, Float64}, NTuple{Dim, Float64}, NTuple{Dim, I}}} where {Dim, I&lt;:Integer}"><code>WaveAcoustics.CartesianMesh</code></a></li><li><a href="#WaveAcoustics.CartesianMesh"><code>WaveAcoustics.CartesianMesh</code></a></li><li><a href="#WaveAcoustics.DOFMap-Union{Tuple{I}, Tuple{Dim}, Tuple{WaveAcoustics.CartesianMesh{Dim, I}, WaveAcoustics.FEFamily, WaveAcoustics.DirichletSides}} where {Dim, I&lt;:Integer}"><code>WaveAcoustics.DOFMap</code></a></li><li><a href="#WaveAcoustics.DOFMap"><code>WaveAcoustics.DOFMap</code></a></li><li><a href="#WaveAcoustics.DirichletSides"><code>WaveAcoustics.DirichletSides</code></a></li><li><a href="#WaveAcoustics.FEFamily"><code>WaveAcoustics.FEFamily</code></a></li><li><a href="#WaveAcoustics.Hermite"><code>WaveAcoustics.Hermite</code></a></li><li><a href="#WaveAcoustics.Lagrange"><code>WaveAcoustics.Lagrange</code></a></li><li><a href="#WaveAcoustics.LeftRight"><code>WaveAcoustics.LeftRight</code></a></li><li><a href="#WaveAcoustics.LeftRightBottomTop"><code>WaveAcoustics.LeftRightBottomTop</code></a></li><li><a href="#WaveAcoustics.LeftRightTop"><code>WaveAcoustics.LeftRightTop</code></a></li><li><a href="#WaveAcoustics.PDECommonData"><code>WaveAcoustics.PDECommonData</code></a></li><li><a href="#WaveAcoustics.PDEInputData"><code>WaveAcoustics.PDEInputData</code></a></li><li><a href="#WaveAcoustics.QuadratureSetup-Union{Tuple{T}, Tuple{Tuple{T, T}, Tuple{T, T}}} where T&lt;:Real"><code>WaveAcoustics.QuadratureSetup</code></a></li><li><a href="#WaveAcoustics.QuadratureSetup"><code>WaveAcoustics.QuadratureSetup</code></a></li><li><a href="#WaveAcoustics.L2_error_1d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:Real, Fun}"><code>WaveAcoustics.L2_error_1d</code></a></li><li><a href="#WaveAcoustics.L2_error_2d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:Real, Fun}"><code>WaveAcoustics.L2_error_2d</code></a></li><li><a href="#WaveAcoustics.apply_EQ!-Union{Tuple{I}, Tuple{Vector{&lt;:StaticArraysCore.SVector}, Vector{&lt;:StaticArraysCore.SVector}, Vector{I}}} where I&lt;:Integer"><code>WaveAcoustics.apply_EQ!</code></a></li><li><a href="#WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, N, T}, WaveAcoustics.DOFMap{&lt;:AbstractVector, I}}} where {N, T, I&lt;:Integer}"><code>WaveAcoustics.assembly_global_matrix</code></a></li><li><a href="#WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{LinearAlgebra.Symmetric{T, &lt;:StaticArraysCore.SMatrix{N, N, T}}, WaveAcoustics.DOFMap{&lt;:AbstractVector, I}}} where {N, T, I&lt;:Integer}"><code>WaveAcoustics.assembly_global_matrix</code></a></li><li><a href="#WaveAcoustics.assembly_global_matrix_DF-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, Fun}"><code>WaveAcoustics.assembly_global_matrix_DF</code></a></li><li><a href="#WaveAcoustics.assembly_global_matrix_DG-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, Fun}"><code>WaveAcoustics.assembly_global_matrix_DG</code></a></li><li><a href="#WaveAcoustics.assembly_local_matrix_DF!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SMatrix{Npg, Npg, &lt;:StaticArraysCore.SMatrix{nb, nb, T}}, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}}} where {T&lt;:AbstractFloat, I&lt;:Integer, nb, Npg, Fun}"><code>WaveAcoustics.assembly_local_matrix_DF!</code></a></li><li><a href="#WaveAcoustics.assembly_local_matrix_DG!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SVector{Npg, T}, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, nb, Npg, Fun}"><code>WaveAcoustics.assembly_local_matrix_DG!</code></a></li><li><a href="#WaveAcoustics.assembly_local_matrix_ϕxϕ"><code>WaveAcoustics.assembly_local_matrix_ϕxϕ</code></a></li><li><a href="#WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ"><code>WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ</code></a></li><li><a href="#WaveAcoustics.assembly_nonlinearity_F!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, Fun}"><code>WaveAcoustics.assembly_nonlinearity_F!</code></a></li><li><a href="#WaveAcoustics.assembly_nonlinearity_G!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, Fun}"><code>WaveAcoustics.assembly_nonlinearity_G!</code></a></li><li><a href="#WaveAcoustics.assembly_rhs_1d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg}, StaticArraysCore.SVector{nb, T}, 1, Npg}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}}} where {T&lt;:Real, Npg, nb, I&lt;:Integer, Fun}"><code>WaveAcoustics.assembly_rhs_1d!</code></a></li><li><a href="#WaveAcoustics.assembly_rhs_2d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}, StaticArraysCore.SVector{Npg, T}}} where {T&lt;:Real, Npg, nb, I&lt;:Integer, Fun}"><code>WaveAcoustics.assembly_rhs_2d!</code></a></li><li><a href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T&lt;:Real}"><code>WaveAcoustics.basis_functions</code></a></li><li><a href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a></li><li><a href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a></li><li><a href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a></li><li><a href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a></li><li><a href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a></li><li><a href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T&lt;:Real}"><code>WaveAcoustics.basis_functions_derivatives</code></a></li><li><a href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a></li><li><a href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a></li><li><a href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a></li><li><a href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a></li><li><a href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a></li><li><a href="#WaveAcoustics.build_EQ"><code>WaveAcoustics.build_EQ</code></a></li><li><a href="#WaveAcoustics.build_LG"><code>WaveAcoustics.build_LG</code></a></li><li><a href="#WaveAcoustics.compute_A!-Union{Tuple{S}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, S}, LinearAlgebra.Symmetric{T, S}, T, T, LinearAlgebra.Symmetric{T, S}}} where {T, S&lt;:(SparseArrays.SparseMatrixCSC{T})}"><code>WaveAcoustics.compute_A!</code></a></li><li><a href="#WaveAcoustics.compute_A₁₁!-Tuple{AbstractMatrix, AbstractMatrix, Real, Real, AbstractMatrix}"><code>WaveAcoustics.compute_A₁₁!</code></a></li><li><a href="#WaveAcoustics.compute_A₁₂!-Tuple{AbstractMatrix, Real, Real, AbstractMatrix}"><code>WaveAcoustics.compute_A₁₂!</code></a></li><li><a href="#WaveAcoustics.compute_DHX₁₁!-NTuple{13, Any}"><code>WaveAcoustics.compute_DHX₁₁!</code></a></li><li><a href="#WaveAcoustics.compute_Lm₁!-NTuple{13, Any}"><code>WaveAcoustics.compute_Lm₁!</code></a></li><li><a href="#WaveAcoustics.compute_Lm₂!-NTuple{15, Any}"><code>WaveAcoustics.compute_Lm₂!</code></a></li><li><a href="#WaveAcoustics.compute_element_diameter-Union{Tuple{T}, Tuple{I}, Tuple{I, Tuple{T, T}, Tuple{T, T}}} where {I&lt;:Integer, T&lt;:AbstractFloat}"><code>WaveAcoustics.compute_element_diameter</code></a></li><li><a href="#WaveAcoustics.compute_minusHX!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Any, Any, Any, Any, Any, Any, T, T, T, WaveAcoustics.CNCache{T}}} where T"><code>WaveAcoustics.compute_minusHX!</code></a></li><li><a href="#WaveAcoustics.compute_r⁰_z⁰!-NTuple{7, Any}"><code>WaveAcoustics.compute_r⁰_z⁰!</code></a></li><li><a href="#WaveAcoustics.compute_rⁿ!-Union{Tuple{Ff₂}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Any, Ff₂, T, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, WaveAcoustics.CNLCache}} where {T, Ff₂}"><code>WaveAcoustics.compute_rⁿ!</code></a></li><li><a href="#WaveAcoustics.compute_v⁰_d⁰!-NTuple{7, Any}"><code>WaveAcoustics.compute_v⁰_d⁰!</code></a></li><li><a href="#WaveAcoustics.compute_vⁿ!-Union{Tuple{Ff1}, Tuple{Ff}, Tuple{Fg}, Tuple{Fα}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Fα, Fg, Ff, Ff1, T, T, T, T, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any, Any, WaveAcoustics.CNLCache}} where {T, Fα, Fg, Ff, Ff1}"><code>WaveAcoustics.compute_vⁿ!</code></a></li><li><a href="#WaveAcoustics.convergence_test_coupled-Tuple{}"><code>WaveAcoustics.convergence_test_coupled</code></a></li><li><a href="#WaveAcoustics.convergence_test_spatial-Tuple{}"><code>WaveAcoustics.convergence_test_spatial</code></a></li><li><a href="#WaveAcoustics.convergence_test_temporal-Tuple{}"><code>WaveAcoustics.convergence_test_temporal</code></a></li><li><a href="#WaveAcoustics.crank_nicolson-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T&lt;:Real"><code>WaveAcoustics.crank_nicolson</code></a></li><li><a href="#WaveAcoustics.crank_nicolson_linearized-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T&lt;:Real"><code>WaveAcoustics.crank_nicolson_linearized</code></a></li><li><a href="#WaveAcoustics.example1_common_data-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example1_common_data</code></a></li><li><a href="#WaveAcoustics.example1_manufactured-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example1_manufactured</code></a></li><li><a href="#WaveAcoustics.example1_zero_source-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example1_zero_source</code></a></li><li><a href="#WaveAcoustics.example2_common_data-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example2_common_data</code></a></li><li><a href="#WaveAcoustics.example2_manufactured-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example2_manufactured</code></a></li><li><a href="#WaveAcoustics.example2_zero_source-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example2_zero_source</code></a></li><li><a href="#WaveAcoustics.manufactured_solution_case-Union{Tuple{T}, Tuple{PDECommonData{T}, Vararg{Any, 6}}} where T"><code>WaveAcoustics.manufactured_solution_case</code></a></li><li><a href="#WaveAcoustics.num_local_dof"><code>WaveAcoustics.num_local_dof</code></a></li><li><a href="#WaveAcoustics.pde_solve-Union{Tuple{T}, Tuple{I}, Tuple{Tuple{I, I}, T, Any}, Tuple{Tuple{I, I}, T, Any, WaveAcoustics.ODESolver}} where {I&lt;:Integer, T&lt;:Real}"><code>WaveAcoustics.pde_solve</code></a></li><li><a href="#WaveAcoustics.polynomial_degree"><code>WaveAcoustics.polynomial_degree</code></a></li><li><a href="#WaveAcoustics.print_convergence_table-Tuple{Any}"><code>WaveAcoustics.print_convergence_table</code></a></li><li><a href="#WaveAcoustics.projection_H01_2d!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{T}, Tuple{AbstractVector{T}, F1, F2, F3, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, AbstractVector{T}, AbstractVector{T}}} where {T, F1, F2, F3}"><code>WaveAcoustics.projection_H01_2d!</code></a></li><li><a href="#WaveAcoustics.run_convergence_study-Tuple{Any, Any, Any, Any, WaveAcoustics.ODESolver, String}"><code>WaveAcoustics.run_convergence_study</code></a></li><li><a href="#WaveAcoustics.solve_ode-Tuple{CrankNicolson, Vararg{Any, 12}}"><code>WaveAcoustics.solve_ode</code></a></li><li><a href="#WaveAcoustics.solve_ode-Tuple{CrankNicolsonLinearized, Vararg{Any, 12}}"><code>WaveAcoustics.solve_ode</code></a></li><li><a href="#WaveAcoustics.zero_source_case-Union{Tuple{PDECommonData{T}}, Tuple{T}} where T"><code>WaveAcoustics.zero_source_case</code></a></li></ul><h2 id="Mesh"><a class="docs-heading-anchor" href="#Mesh">Mesh</a><a id="Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.AbstractMesh"><a class="docstring-binding" href="#WaveAcoustics.AbstractMesh"><code>WaveAcoustics.AbstractMesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractMesh{Dim}</code></pre><p>Abstract supertype for meshes in dimension <code>Dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/mesh.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.CartesianMesh"><a class="docstring-binding" href="#WaveAcoustics.CartesianMesh"><code>WaveAcoustics.CartesianMesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CartesianMesh{Dim,I} &lt;: AbstractMesh{Dim}</code></pre><p>Uniform Cartesian mesh in dimension <code>Dim</code> with integer type <code>I</code>.</p><p><strong>Fields</strong></p><ul><li><code>pmin::NTuple{Dim,Float64}</code>: Domain lower corner</li><li><code>pmax::NTuple{Dim,Float64}</code>: Domain upper corner</li><li><code>Nx::NTuple{Dim,I}</code>: Number of elements per direction</li><li><code>Δx::NTuple{Dim,Float64}</code>: Element sizes per direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/mesh.jl#L8-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.CartesianMesh-Union{Tuple{I}, Tuple{Dim}, Tuple{NTuple{Dim, Float64}, NTuple{Dim, Float64}, NTuple{Dim, I}}} where {Dim, I&lt;:Integer}"><a class="docstring-binding" href="#WaveAcoustics.CartesianMesh-Union{Tuple{I}, Tuple{Dim}, Tuple{NTuple{Dim, Float64}, NTuple{Dim, Float64}, NTuple{Dim, I}}} where {Dim, I&lt;:Integer}"><code>WaveAcoustics.CartesianMesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CartesianMesh(pmin, pmax, Nx)</code></pre><p>Construct uniform Cartesian mesh partitioning <code>[pmin, pmax]</code> (1D) or  <code>[pmin[1], pmax[1]] × [pmin[2], pmax[2]]</code> (2D) into <code>Nx</code> elements per direction.</p><p><strong>Arguments</strong></p><ul><li><code>pmin::NTuple{Dim,Float64}</code>: Domain lower corner</li><li><code>pmax::NTuple{Dim,Float64}</code>: Domain upper corner</li><li><code>Nx::NTuple{Dim,I}</code>: Number of elements per direction</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mesh1d = WaveAcoustics.CartesianMesh((0.0,), (1.0,), (10,));

julia&gt; mesh1d.Δx
(0.1,)

julia&gt; mesh2d = WaveAcoustics.CartesianMesh((0.0, 0.0), (1.0, 2.0), (10, 20));

julia&gt; mesh2d.Δx
(0.1, 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/mesh.jl#L26-L49">source</a></section></details></article><h2 id="Finite-Element-Families"><a class="docs-heading-anchor" href="#Finite-Element-Families">Finite Element Families</a><a id="Finite-Element-Families-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Element-Families" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.FEFamily"><a class="docstring-binding" href="#WaveAcoustics.FEFamily"><code>WaveAcoustics.FEFamily</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FEFamily</code></pre><p>Abstract supertype for finite element families.</p><p>Concrete subtypes must specify spatial dimension <code>Dim</code> and polynomial degree <code>Deg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/fe_families.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.Hermite"><a class="docstring-binding" href="#WaveAcoustics.Hermite"><code>WaveAcoustics.Hermite</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Hermite{Dim,Deg} &lt;: FEFamily</code></pre><p>Hermite finite element of dimension <code>Dim</code> and degree <code>Deg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/fe_families.jl#L17-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.Lagrange"><a class="docstring-binding" href="#WaveAcoustics.Lagrange"><code>WaveAcoustics.Lagrange</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Lagrange{Dim,Deg} &lt;: FEFamily</code></pre><p>Lagrange finite element of dimension <code>Dim</code> and degree <code>Deg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/fe_families.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.num_local_dof"><a class="docstring-binding" href="#WaveAcoustics.num_local_dof"><code>WaveAcoustics.num_local_dof</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">num_local_dof(family::FEFamily)</code></pre><p>Return number of local DOFs for the finite element family.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; WaveAcoustics.num_local_dof(Lagrange{2,3}())
16

julia&gt; WaveAcoustics.num_local_dof(Hermite{1,3}())
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/fe_families.jl#L24-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.polynomial_degree"><a class="docstring-binding" href="#WaveAcoustics.polynomial_degree"><code>WaveAcoustics.polynomial_degree</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">polynomial_degree(family::FEFamily)</code></pre><p>Return polynomial degree for the finite element family.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; WaveAcoustics.polynomial_degree(Lagrange{2,3}())
3

julia&gt; WaveAcoustics.polynomial_degree(Hermite{1,3}())
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/fe_families.jl#L44-L57">source</a></section></details></article><h2 id="Basis-Functions"><a class="docs-heading-anchor" href="#Basis-Functions">Basis Functions</a><a id="Basis-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Functions" title="Permalink"></a></h2><h3 id="1D-Lagrange-Elements"><a class="docs-heading-anchor" href="#1D-Lagrange-Elements">1D Lagrange Elements</a><a id="1D-Lagrange-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#1D-Lagrange-Elements" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions(::Lagrange{1,1}, ξ)</code></pre><p>Linear Lagrange basis functions on the reference interval [-1, 1].</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Coordinate in the reference element [-1, 1]</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{2,T}</code>: Values of the two basis functions [ϕ₁(ξ), ϕ₂(ξ)]</li></ul><p><strong>Node Layout</strong></p><pre><code class="language-julia hljs">1 --- 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L5-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 1}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions_derivatives(::Lagrange{1,1}, ξ)</code></pre><p>Derivatives of linear Lagrange basis functions with respect to ξ.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Coordinate in the reference element [-1, 1]</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{2,T}</code>: Derivatives [dϕ₁/dξ, dϕ₂/dξ]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L29-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions(::Lagrange{1,2}, ξ)</code></pre><p>Quadratic Lagrange basis functions on the reference interval [-1, 1].</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Coordinate in the reference element [-1, 1]</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{3,T}</code>: Values of the three basis functions [ϕ₁(ξ), ϕ₂(ξ), ϕ₃(ξ)]</li></ul><p><strong>Node Layout</strong></p><pre><code class="language-julia hljs">1 --- 2 --- 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L46-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 2}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions_derivatives(::Lagrange{1,2}, ξ)</code></pre><p>Derivatives of quadratic Lagrange basis functions with respect to ξ.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Coordinate in the reference element [-1, 1]</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{3,T}</code>: Derivatives [dϕ₁/dξ, dϕ₂/dξ, dϕ₃/dξ]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L71-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions(::Lagrange{1,3}, ξ)</code></pre><p>Cubic Lagrange basis functions on the reference interval [-1, 1].</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Coordinate in the reference element [-1, 1]</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{4,T}</code>: Values of the four basis functions [ϕ₁(ξ), ϕ₂(ξ), ϕ₃(ξ), ϕ₄(ξ)]</li></ul><p><strong>Node Layout</strong></p><pre><code class="language-julia hljs">1 --- 2 --- 3 --- 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L91-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Lagrange{1, 3}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions_derivatives(::Lagrange{1,3}, ξ)</code></pre><p>Derivatives of cubic Lagrange basis functions with respect to ξ.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Coordinate in the reference element [-1, 1]</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{4,T}</code>: Derivatives [dϕ₁/dξ, dϕ₂/dξ, dϕ₃/dξ, dϕ₄/dξ]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L117-L127">source</a></section></details></article><h3 id="2D-Lagrange-Elements"><a class="docs-heading-anchor" href="#2D-Lagrange-Elements">2D Lagrange Elements</a><a id="2D-Lagrange-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Lagrange-Elements" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T&lt;:Real}"><a class="docstring-binding" href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T&lt;:Real}"><code>WaveAcoustics.basis_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions(::Lagrange{2,Deg}, ξ, η)</code></pre><p>Tensor-product Lagrange basis functions on the reference square [-1,1] × [-1,1].</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: First coordinate in the reference element</li><li><code>η::T</code>: Second coordinate in the reference element</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{(Deg+1)²,T}</code>: Values of all basis functions</li></ul><p><strong>Node Layout (Deg = 1)</strong></p><pre><code class="language-julia hljs">3 --- 4
|     |
1 --- 2</code></pre><p><strong>Node Layout (Deg = 2)</strong></p><pre><code class="language-julia hljs">7 --- 8 --- 9
|     |     |
4 --- 5 --- 6
|     |     |
1 --- 2 --- 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L142-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T&lt;:Real}"><a class="docstring-binding" href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Deg}, Tuple{Lagrange{2, Deg}, T, T}} where {Deg, T&lt;:Real}"><code>WaveAcoustics.basis_functions_derivatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions_derivatives(::Lagrange{2,Deg}, ξ, η)</code></pre><p>Derivatives of tensor-product Lagrange basis functions.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: First coordinate in the reference element</li><li><code>η::T</code>: Second coordinate in the reference element</li></ul><p><strong>Returns</strong></p><ul><li>Tuple <code>(∂ϕ/∂ξ, ∂ϕ/∂η)</code> where:<ul><li><code>∂ϕ/∂ξ::SVector{(Deg+1)²,T}</code>: Derivatives ∂ϕᵢ/∂ξ</li><li><code>∂ϕ/∂η::SVector{(Deg+1)²,T}</code>: Derivatives ∂ϕᵢ/∂η</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L185-L198">source</a></section></details></article><h3 id="1D-Hermite-Elements"><a class="docs-heading-anchor" href="#1D-Hermite-Elements">1D Hermite Elements</a><a id="1D-Hermite-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#1D-Hermite-Elements" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions(::Hermite{1,3}, ξ)</code></pre><p>Cubic Hermite basis functions on the reference interval [-1, 1].</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Coordinate in the reference element [-1, 1]</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{4,T}</code>: Values [H₁(ξ), H₁&#39;(ξ), H₂(ξ), H₂&#39;(ξ)]</li></ul><p><strong>Node Layout</strong></p><pre><code class="language-julia hljs">1:2 ---- 3:4</code></pre><p>Each node has 2 DOFs: (u, du/dξ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L228-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{1, 3}, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions_derivatives(::Hermite{1,3}, ξ)</code></pre><p>Derivatives of cubic Hermite basis functions with respect to ξ.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: Coordinate in the reference element [-1, 1]</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{4,T}</code>: Derivatives [dH₁/dξ, dH₁&#39;/dξ, dH₂/dξ, dH₂&#39;/dξ]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L255-L265">source</a></section></details></article><h3 id="2D-Hermite-Elements"><a class="docs-heading-anchor" href="#2D-Hermite-Elements">2D Hermite Elements</a><a id="2D-Hermite-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Hermite-Elements" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions(::Hermite{2,3}, ξ, η)</code></pre><p>Bicubic Hermite basis functions on the reference square [-1,1] × [-1,1].</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: First coordinate in the reference element</li><li><code>η::T</code>: Second coordinate in the reference element</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{16,T}</code>: Values of all 16 basis functions</li></ul><p><strong>Node Layout</strong></p><pre><code class="language-julia hljs"> 9:12 ---- 13:16
  |          |
  |          |
 1:4  ----  5:8</code></pre><p>Each corner node has 4 DOFs: (u, ∂u/∂ξ, ∂u/∂η, ∂²u/∂ξ∂η)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L280-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.basis_functions_derivatives-Union{Tuple{T}, Tuple{Hermite{2, 3}, T, T}} where T&lt;:Real"><code>WaveAcoustics.basis_functions_derivatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_functions_derivatives(::Hermite{2,3}, ξ, η)</code></pre><p>Derivatives of Bicubic Hermite basis functions.</p><p><strong>Arguments</strong></p><ul><li><code>ξ::T</code>: First coordinate in the reference element</li><li><code>η::T</code>: Second coordinate in the reference element</li></ul><p><strong>Returns</strong></p><ul><li>Tuple <code>(∂ϕ/∂ξ, ∂ϕ/∂η)</code> where:<ul><li><code>∂ϕ/∂ξ::SVector{16,T}</code>: Derivatives ∂ϕᵢ/∂ξ</li><li><code>∂ϕ/∂η::SVector{16,T}</code>: Derivatives ∂ϕᵢ/∂η</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/basis_functions.jl#L334-L347">source</a></section></details></article><h2 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.DirichletSides"><a class="docstring-binding" href="#WaveAcoustics.DirichletSides"><code>WaveAcoustics.DirichletSides</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DirichletSides</code></pre><p>Abstract supertype for domain sides with Dirichlet BCs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/boundary_conditions.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.LeftRight"><a class="docstring-binding" href="#WaveAcoustics.LeftRight"><code>WaveAcoustics.LeftRight</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LeftRight &lt;: DirichletSides</code></pre><p>Dirichlet boundary conditions imposed on the left and right sides of a 1D domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/boundary_conditions.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.LeftRightBottomTop"><a class="docstring-binding" href="#WaveAcoustics.LeftRightBottomTop"><code>WaveAcoustics.LeftRightBottomTop</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LeftRightBottomTop &lt;: DirichletSides</code></pre><p>Dirichlet boundary conditions imposed on all four sides (left, right, bottom, and top) of a 2D domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/boundary_conditions.jl#L15-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.LeftRightTop"><a class="docstring-binding" href="#WaveAcoustics.LeftRightTop"><code>WaveAcoustics.LeftRightTop</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LeftRightTop &lt;: DirichletSides</code></pre><p>Dirichlet boundary conditions imposed on the left, right, and top sides of a 2D domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/boundary_conditions.jl#L23-L28">source</a></section></details></article><h2 id="DOF-Map"><a class="docs-heading-anchor" href="#DOF-Map">DOF Map</a><a id="DOF-Map-1"></a><a class="docs-heading-anchor-permalink" href="#DOF-Map" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.DOFMap"><a class="docstring-binding" href="#WaveAcoustics.DOFMap"><code>WaveAcoustics.DOFMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DOFMap{T &lt;: AbstractVector, I &lt;: Integer}</code></pre><p>Local-to-global DOF mapping with homogeneous Dirichlet BCs enforced on the FE approximation subspace.</p><p><strong>Fields</strong></p><ul><li><code>EQoLG::T</code>: Element connectivity. <code>EQoLG[e][a]</code> gives global index of local DOF <code>a</code> in element <code>e</code></li><li><code>m::I</code>: Number of free DOFs after homogeneous Dirichlet BC enforcement on the FE approximation subspace</li></ul><p><strong>Indexing Convention</strong></p><ul><li>Global functions in the approximation subspace: indices <code>1, 2, ..., m</code></li><li>Global functions NOT in the approximation subspace: sentinel value <code>m+1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/dof_map.jl#L2-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.DOFMap-Union{Tuple{I}, Tuple{Dim}, Tuple{WaveAcoustics.CartesianMesh{Dim, I}, WaveAcoustics.FEFamily, WaveAcoustics.DirichletSides}} where {Dim, I&lt;:Integer}"><a class="docstring-binding" href="#WaveAcoustics.DOFMap-Union{Tuple{I}, Tuple{Dim}, Tuple{WaveAcoustics.CartesianMesh{Dim, I}, WaveAcoustics.FEFamily, WaveAcoustics.DirichletSides}} where {Dim, I&lt;:Integer}"><code>WaveAcoustics.DOFMap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DOFMap(mesh::CartesianMesh, family::FEFamily, sides::DirichletSides)</code></pre><p>Construct DOF map for given mesh, element family, and Dirichlet boundary conditions.</p><p><strong>Arguments</strong></p><ul><li><code>mesh</code>: Cartesian mesh</li><li><code>family</code>: Finite element family (e.g., <code>Lagrange{2,3}()</code>)</li><li><code>sides</code>: Dirichlet boundary condition specification (e.g., <code>LeftRight()</code>)</li></ul><p><strong>Returns</strong></p><p><code>DOFMap</code> containing element connectivity and number of free DOFs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mesh = WaveAcoustics.CartesianMesh((0.0,), (1.0,), (4,));

julia&gt; dofmap = WaveAcoustics.DOFMap(mesh, WaveAcoustics.Lagrange{1,1}(), WaveAcoustics.LeftRight());

julia&gt; dofmap.EQoLG
4-element Vector{StaticArraysCore.SVector{2, Int64}}:
 [4, 1]
 [1, 2]
 [2, 3]
 [3, 4]

julia&gt; dofmap.m
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/dof_map.jl#L20-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.apply_EQ!-Union{Tuple{I}, Tuple{Vector{&lt;:StaticArraysCore.SVector}, Vector{&lt;:StaticArraysCore.SVector}, Vector{I}}} where I&lt;:Integer"><a class="docstring-binding" href="#WaveAcoustics.apply_EQ!-Union{Tuple{I}, Tuple{Vector{&lt;:StaticArraysCore.SVector}, Vector{&lt;:StaticArraysCore.SVector}, Vector{I}}} where I&lt;:Integer"><code>WaveAcoustics.apply_EQ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_EQ!(EQoLG, LG, EQ)</code></pre><p>Apply equation numbering to local-to-global map (in-place).</p><p>Transforms <code>LG</code> (before BCs) into <code>EQoLG</code> (after BCs) using <code>EQ</code> mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/dof_map.jl#L222-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.build_EQ"><a class="docstring-binding" href="#WaveAcoustics.build_EQ"><code>WaveAcoustics.build_EQ</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">build_EQ(Nx, family, sides)</code></pre><p>Build equation numbering array that enforces homogeneous Dirichlet BCs.</p><p><strong>Returns</strong></p><ul><li><code>EQ</code>: Array mapping global DOF index (before BCs) to free DOF index (after BCs)</li><li><code>m</code>: Number of free DOFs</li></ul><p><strong>Indexing Convention</strong></p><ul><li>Global functions in the approximation subspace: indices <code>1, 2, ..., m</code></li><li>Global functions NOT in the approximation subspace: sentinel value <code>m+1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/dof_map.jl#L133-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.build_LG"><a class="docstring-binding" href="#WaveAcoustics.build_LG"><code>WaveAcoustics.build_LG</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">build_LG(mesh, family)</code></pre><p>Build local-to-global DOF map before BC enforcement.</p><p>Returns vector <code>LG</code> where <code>LG[e]</code> contains global DOF indices for element <code>e</code>. Uses tensor product ordering: DOFs numbered left-to-right, bottom-to-top.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/dof_map.jl#L68-L75">source</a></section></details></article><h2 id="Quadrature-Setup"><a class="docs-heading-anchor" href="#Quadrature-Setup">Quadrature Setup</a><a id="Quadrature-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature-Setup" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.QuadratureSetup"><a class="docstring-binding" href="#WaveAcoustics.QuadratureSetup"><code>WaveAcoustics.QuadratureSetup</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuadratureSetup{T&lt;:Real}</code></pre><p>Precomputed quadrature data for finite element assembly using Gauss-Legendre quadrature.</p><p><strong>Fields</strong></p><ul><li><code>P, W</code>: Quadrature points and weights in [-1,1].</li><li><code>ϕP, W_ϕP, W_ϕPϕP</code>: 1D basis functions and weighted products.</li><li><code>φP, W_φP, W_φPφP</code>: 2D basis functions and weighted products</li><li><code>W_∂φ∂ξP, W_∂φ∂ηP</code>: Weighted basis function derivatives</li><li><code>xP, yP</code>:  Precomputed fixed part of physical quad points: <code>(Δx/2)*(P+1) + xmin</code>, <code>(Δy/2)*(P+1) + ymin</code></li></ul><p><strong>Notes</strong></p><ul><li>Currently specialized for <code>Npg = 4</code> Gauss–Legendre points per dimension</li><li>Currently specialized for linear Lagrange basis functions</li><li>For element at indices <code>(ex, ey)</code>, physical quadrature coordinates are:</li></ul><pre><code class="language-julia hljs">xeP = @. xP + (ex - 1) * Δx
yeP = @. yP + (ey - 1) * Δy</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/quadrature_setup.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.QuadratureSetup-Union{Tuple{T}, Tuple{Tuple{T, T}, Tuple{T, T}}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.QuadratureSetup-Union{Tuple{T}, Tuple{Tuple{T, T}, Tuple{T, T}}} where T&lt;:Real"><code>WaveAcoustics.QuadratureSetup</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QuadratureSetup(Δx, pmin)</code></pre><p>Construct quadrature setup with <code>4</code> Gauss-Legendre points per dimension.</p><p><strong>Arguments</strong></p><ul><li><code>Δx::NTuple{2,T}</code>: Element sizes per direction</li><li><code>pmin::NTuple{2,T}</code>: Domain bottom-left corner <code>(xmin, ymin)</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; quad = WaveAcoustics.QuadratureSetup((0.1, 0.2), (0.0, 0.0));

julia&gt; length(quad.xP)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/quadrature_setup.jl#L37-L53">source</a></section></details></article><h2 id="Assemble-local-matrices"><a class="docs-heading-anchor" href="#Assemble-local-matrices">Assemble local matrices</a><a id="Assemble-local-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-local-matrices" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_local_matrix_DF!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SMatrix{Npg, Npg, &lt;:StaticArraysCore.SMatrix{nb, nb, T}}, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}}} where {T&lt;:AbstractFloat, I&lt;:Integer, nb, Npg, Fun}"><a class="docstring-binding" href="#WaveAcoustics.assembly_local_matrix_DF!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SMatrix{Npg, Npg, &lt;:StaticArraysCore.SMatrix{nb, nb, T}}, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}}} where {T&lt;:AbstractFloat, I&lt;:Integer, nb, Npg, Fun}"><code>WaveAcoustics.assembly_local_matrix_DF!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_local_matrix_DF!(DF, f, d, m, eq, W_φPφP, φP)</code></pre><p>DFₐᵦ = ∬ φₐ(ξ,η) φᵦ(ξ,η) f(Uₕ(x(ξ,η),y(ξ,η))) dξ dη over reference element Ω = (-1,1)², with Uₕ(x(ξ,η),y(ξ,η)) = Σ d[eq[j]] φⱼ(ξ,η).</p><p><strong>Arguments</strong></p><ul><li><code>DF::AbstractMatrix{T}</code>: Local matrix (nb × nb), zeroed and filled in-place <strong>only in upper triangle</strong></li><li><code>f::Fun</code>: Callable f(s) → T</li><li><code>d::AbstractVector{T}</code>: Coefficient vector for Uₕ, length <code>m</code></li><li><code>m::I</code>: Number of active DOFs</li><li><code>eq::SVector{nb,I}</code>: Local-to-global DOF mapping for element <code>e</code> (EQoLG[e])</li><li><code>W_φPφP::SMatrix{Npg,Npg,&lt;:SMatrix{nb,nb,T}}</code>: Precomputed <code>Wᵢ⋅Wⱼ⋅φₐ(Pᵢ,Pⱼ)⋅φᵦ(Pᵢ,Pⱼ)</code> (NO Jacobian, NO scale)</li><li><code>φP::SMatrix{Npg,Npg,SVector{nb,T}}</code>: Precomputed <code>φ(Pᵢ,Pⱼ)</code></li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Floating point type</li><li><code>I</code>: Integer type</li><li><code>nb</code>: Number of basis functions per element</li><li><code>Npg</code>: Number of quadrature points per element in each axis direction </li><li><code>Fun</code>: Function type</li></ul><p><strong>Notes</strong></p><ul><li>Scaling factor and Jacobian are NOT applied here</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_local_matrices.jl#L171-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_local_matrix_DG!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SVector{Npg, T}, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, nb, Npg, Fun}"><a class="docstring-binding" href="#WaveAcoustics.assembly_local_matrix_DG!-Union{Tuple{Fun}, Tuple{Npg}, Tuple{nb}, Tuple{I}, Tuple{T}, Tuple{AbstractMatrix{T}, Fun, AbstractVector{T}, I, StaticArraysCore.SVector{nb, I}, StaticArraysCore.SVector{Npg, T}, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, nb, Npg, Fun}"><code>WaveAcoustics.assembly_local_matrix_DG!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_local_matrix_DG!(DG, ∂ₛg, v, m, eq, xeP, W_ϕPϕP, ϕP)</code></pre><p>DGₐᵦ = ∫ ϕₐ(ξ) * ϕᵦ(ξ) * ∂ₛg(x(ξ), Vₕ(x(ξ))) dx over Ω = (-1,1), with Vₕ(x(ξ)) = Σ v[eq[j]] ϕⱼ(ξ).</p><p><strong>Arguments</strong></p><ul><li><code>DG::AbstractMatrix{T}</code>: Local matrix (nb × nb), zeroed and filled in-place <strong>only in upper triangle</strong></li><li><code>∂ₛg::Fun</code>: Callable ∂ₛg(x, s) → T</li><li><code>v::AbstractVector{T}</code>: Coefficient vector for Vₕ, length <code>m</code></li><li><code>m::I</code>: Number of active DOFs</li><li><code>eq::SVector{nb,I}</code>: Local-to-global DOF mapping for element <code>e</code> (EQoLG[e])</li><li><code>xeP::SVector{Npg,T}</code>: Physical quadrature points (<code>xᵉ(P) = (Δx/2)*(P + 1) + x_start + (e-1)*Δx</code>)</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Floating point type</li><li><code>I</code>: Integer type</li><li><code>nb</code>: Number of basis functions per element</li><li><code>Npg</code>: Number of quadrature points per element</li><li><code>Fun</code>: Function type</li></ul><p><strong>Notes</strong></p><ul><li>Scaling factor and Jacobian are NOT applied here</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_local_matrices.jl#L113-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_local_matrix_ϕxϕ"><a class="docstring-binding" href="#WaveAcoustics.assembly_local_matrix_ϕxϕ"><code>WaveAcoustics.assembly_local_matrix_ϕxϕ</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">assembly_local_matrix_ϕxϕ(mesh, family)</code></pre><p>Assemble the local mass matrix ∫_{Ωₑ} ϕₐᵉ ϕᵦᵉ dx for an arbitrary element Ωₑ.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::CartesianMesh{Dim}</code>: Uniform Cartesian mesh defining element geometry</li><li><code>family::FEFamily</code>: Finite element family</li></ul><p><strong>Returns</strong></p><ul><li><code>SMatrix{N,N}</code>: Local mass matrix where <code>N = num_local_dof(family)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_local_matrices.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ"><a class="docstring-binding" href="#WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ"><code>WaveAcoustics.assembly_local_matrix_∇ϕx∇ϕ</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">assembly_local_matrix_∇ϕx∇ϕ(mesh, family)</code></pre><p>Assemble the local stiffness matrix ∫_{Ωₑ} ∇ϕₐᵉ · ∇ϕᵦᵉ dx for an arbitrary element Ωₑ.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::CartesianMesh{Dim}</code>: Uniform Cartesian mesh defining element geometry</li><li><code>family::FEFamily</code>: Finite element family</li></ul><p><strong>Returns</strong></p><ul><li><code>SMatrix{N,N}</code>: Local stiffness matrix where <code>N = num_local_dof(family)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_local_matrices.jl#L56-L67">source</a></section></details></article><h2 id="Assemble-global-matrices"><a class="docs-heading-anchor" href="#Assemble-global-matrices">Assemble global matrices</a><a id="Assemble-global-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-global-matrices" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{LinearAlgebra.Symmetric{T, &lt;:StaticArraysCore.SMatrix{N, N, T}}, WaveAcoustics.DOFMap{&lt;:AbstractVector, I}}} where {N, T, I&lt;:Integer}"><a class="docstring-binding" href="#WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{LinearAlgebra.Symmetric{T, &lt;:StaticArraysCore.SMatrix{N, N, T}}, WaveAcoustics.DOFMap{&lt;:AbstractVector, I}}} where {N, T, I&lt;:Integer}"><code>WaveAcoustics.assembly_global_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_global_matrix(local_matrix, dof_map) -&gt; Symmetric{T, SparseMatrixCSC{T,I}}</code></pre><p>Assemble global symmetric FEM matrix from element-local symmetric matrix. Only stores upper triangle, reducing memory and assembly time.</p><p><strong>Arguments</strong></p><ul><li><code>local_matrix::Symmetric{T, &lt;:SMatrix{N,N,T}}</code>: Symmetric element matrix (N×N)</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li></ul><p><strong>Returns</strong></p><ul><li><code>Symmetric{T, SparseMatrixCSC{T,I}}</code>: Assembled symmetric global matrix (m×m)</li></ul><p><strong>Assumptions</strong></p><p>Assumes <code>a ≤ b ⇒ ia ≤ jb</code> for all local indices, where <code>ia = EQoLG[e][a]</code> and  <code>jb = EQoLG[e][b]</code>. This condition holds for structured meshes with consistent  left-to-right, bottom-to-top numbering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_global_matrices.jl#L53-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, N, T}, WaveAcoustics.DOFMap{&lt;:AbstractVector, I}}} where {N, T, I&lt;:Integer}"><a class="docstring-binding" href="#WaveAcoustics.assembly_global_matrix-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, N, T}, WaveAcoustics.DOFMap{&lt;:AbstractVector, I}}} where {N, T, I&lt;:Integer}"><code>WaveAcoustics.assembly_global_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_global_matrix(local_matrix, dof_map) -&gt; SparseMatrixCSC</code></pre><p>Assemble global FEM matrix from element-local matrix.</p><p><strong>Arguments</strong></p><ul><li><code>local_matrix::SMatrix{N,N,T}</code>: Element matrix (N×N)</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrixCSC{T,I}</code>: Assembled global matrix (m×m), excluding DOFs &gt; m</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_global_matrices.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_global_matrix_DF-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, Fun}"><a class="docstring-binding" href="#WaveAcoustics.assembly_global_matrix_DF-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, Fun}"><code>WaveAcoustics.assembly_global_matrix_DF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_global_matrix_DF(scale, f, d, mesh, dof_map, quad)</code></pre><p>DFᵢⱼ = scale * ∬ φᵢ(x,y) * φⱼ(x,y) * f(Uₕ(x,y)) dx dy over Ω, with Uₕ(x,y) = Σ d[k] φₖ(x,y).</p><p><strong>Arguments</strong></p><ul><li><code>scale::T</code>: Scaling factor applied to final result</li><li><code>f::Fun</code>: Callable f(s) → T</li><li><code>d::AbstractVector{T}</code>: Coefficient vector for Uₕ, length <code>dof_map.m</code></li><li><code>mesh::CartesianMesh{2, I}</code>: 2D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul><p><strong>Returns</strong></p><ul><li><code>Symmetric{T, SparseMatrixCSC{T,I}}</code>: Assembled symmetric global matrix (m×m)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_global_matrices.jl#L184-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_global_matrix_DG-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, Fun}"><a class="docstring-binding" href="#WaveAcoustics.assembly_global_matrix_DG-Union{Tuple{Fun}, Tuple{I}, Tuple{T}, Tuple{T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, I&lt;:Integer, Fun}"><code>WaveAcoustics.assembly_global_matrix_DG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_global_matrix_DG(scale, ∂ₛg, v, mesh, dof_map, quad)</code></pre><p>DGᵢⱼ = scale * ∫ ϕᵢ(x) * ϕⱼ(x) * ∂ₛg(x, Vₕ(x)) dx over Ω ⊂ ℜ, with Vₕ(x) = Σ v[k] ϕₖ(x).</p><p><strong>Arguments</strong></p><ul><li><code>scale::T</code>: Scaling factor applied to final result</li><li><code>∂ₛg::Fun</code>: Callable ∂ₛg(x, v) → T</li><li><code>v::AbstractVector{T}</code>: Coefficient vector for Vₕ, length <code>dof_map.m</code></li><li><code>mesh::CartesianMesh{1,I}</code>: 1D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul><p><strong>Returns</strong></p><ul><li><code>Symmetric{T, SparseMatrixCSC{T,I}}</code>: Assembled symmetric global matrix (m×m)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_global_matrices.jl#L113-L128">source</a></section></details></article><h2 id="Assemble-global-vectors"><a class="docs-heading-anchor" href="#Assemble-global-vectors">Assemble global vectors</a><a id="Assemble-global-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-global-vectors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_nonlinearity_F!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, Fun}"><a class="docstring-binding" href="#WaveAcoustics.assembly_nonlinearity_F!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, Fun}"><code>WaveAcoustics.assembly_nonlinearity_F!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_nonlinearity_F!(F, scale, f, d, mesh, dof_map, quad)</code></pre><p>Fᵢ = scale * ∬ φᵢ(x,y) * f(Uₕ(x,y)) dx dy over Ω, with Uₕ(x,y) = Σ d[j] φⱼ(x,y).</p><p><strong>Arguments</strong></p><ul><li><code>F::AbstractVector{T}</code>: Global vector (zeroed and filled in-place), length <code>dof_map.m</code></li><li><code>scale::T</code>: Scaling factor applied to final result</li><li><code>f::Fun</code>: Nonlinearity function <code>f(u)</code> returning type <code>T</code></li><li><code>d::AbstractVector{T}</code>: Coefficient vector for Uₕ, length <code>dof_map.m</code></li><li><code>mesh::CartesianMesh{2}</code>: 2D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_global_vectors.jl#L120-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_nonlinearity_G!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, Fun}"><a class="docstring-binding" href="#WaveAcoustics.assembly_nonlinearity_G!-Union{Tuple{Fun}, Tuple{T}, Tuple{AbstractVector{T}, T, Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:AbstractFloat, Fun}"><code>WaveAcoustics.assembly_nonlinearity_G!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_nonlinearity_G!(G, scale, g, v, mesh, dof_map, quad)</code></pre><p>Gᵢ = scale * ∫ ϕᵢ(x) * g(x, Vₕ(x)) dx over Ω = (0,1), with Vₕ(x) = Σ v[j] ϕⱼ(x).</p><p><strong>Arguments</strong></p><ul><li><code>G::AbstractVector{T}</code>: Global vector (zeroed and filled in-place), length <code>dof_map.m</code></li><li><code>scale::T</code>: Scaling factor applied to final result</li><li><code>g::Fun</code>: Callable g(x, v) → scalar</li><li><code>v::AbstractVector{T}</code>: Coefficient vector for Vₕ, length <code>dof_map.m</code></li><li><code>mesh::CartesianMesh{1}</code>: 1D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_global_vectors.jl#L182-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_rhs_1d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg}, StaticArraysCore.SVector{nb, T}, 1, Npg}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}}} where {T&lt;:Real, Npg, nb, I&lt;:Integer, Fun}"><a class="docstring-binding" href="#WaveAcoustics.assembly_rhs_1d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg}, StaticArraysCore.SVector{nb, T}, 1, Npg}, WaveAcoustics.CartesianMesh{1, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}}} where {T&lt;:Real, Npg, nb, I&lt;:Integer, Fun}"><code>WaveAcoustics.assembly_rhs_1d!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_rhs_1d!(F, f, scale, W_basisP, mesh, dof_map, xP)</code></pre><p>Assemble global RHS vector for 1D FEM by integrating f(x) against basis functions.</p><p><strong>Arguments</strong></p><ul><li><code>F::AbstractVector{T}</code>: Global RHS vector (modified in-place, length <code>dof_map.m</code>)</li><li><code>f::Fun</code>: Source function <code>f(x)</code> returning type <code>T</code></li><li><code>scale::T</code>: Scaling factor (typically <code>Δx/2</code> for F[i] = ∫Ω f(x) ϕᵢ(x) dx)</li><li><code>W_basisP::SVector{Npg,SVector{nb,T}}</code>: Precomputed weighted basis evaluations at quadrature points</li><li><code>mesh::CartesianMesh{1,I}</code>: 1D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>xP::SVector{Npg,T}</code>: Precomputed fixed part of physical quad points: (Δx/2)*(P+1) + x_start</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Floating point type for computations</li><li><code>Npg</code>: Number of quadrature points per element</li><li><code>nb</code>: Number of local basis functions per element</li><li><code>I</code>: Integer type for mesh indexing</li><li><code>Fun</code>: Function type for source term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_global_vectors.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.assembly_rhs_2d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}, StaticArraysCore.SVector{Npg, T}}} where {T&lt;:Real, Npg, nb, I&lt;:Integer, Fun}"><a class="docstring-binding" href="#WaveAcoustics.assembly_rhs_2d!-Union{Tuple{Fun}, Tuple{I}, Tuple{nb}, Tuple{Npg}, Tuple{T}, Tuple{AbstractVector{T}, Fun, T, StaticArraysCore.SArray{Tuple{Npg, Npg}, StaticArraysCore.SVector{nb, T}, 2}, WaveAcoustics.CartesianMesh{2, I}, WaveAcoustics.DOFMap, StaticArraysCore.SVector{Npg, T}, StaticArraysCore.SVector{Npg, T}}} where {T&lt;:Real, Npg, nb, I&lt;:Integer, Fun}"><code>WaveAcoustics.assembly_rhs_2d!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assembly_rhs_2d!(F, f, scale, W_basisP, mesh, dof_map, xP, yP)</code></pre><p>Assemble global RHS vector for 2D FEM by integrating f(x,y) against basis functions.</p><p><strong>Arguments</strong></p><ul><li><code>F::AbstractVector{T}</code>: Global RHS vector (modified in-place, length <code>dof_map.m</code>)</li><li><code>f::Fun</code>: Source function <code>f(x,y)</code> returning type <code>T</code></li><li><code>scale::T</code>: Scaling factor (typically <code>Δx*Δy/4</code> for F[i] = ∫Ω f(x,y) φᵢ(x,y) dx dy)</li><li><code>W_basisP::SMatrix{Npg,Npg,SVector{nb,T}}</code>: Precomputed weighted basis evaluations at quadrature points</li><li><code>mesh::CartesianMesh{2,I}</code>: 2D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>xP::SVector{Npg,T}</code>: Precomputed fixed part of physical quad points: (Δx/2)*(P+1) + x_start</li><li><code>yP::SVector{Npg,T}</code>: Precomputed fixed part of physical quad points: (Δy/2)*(P+1) + y_start</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Floating point type for computations</li><li><code>Npg</code>: Number of quadrature points per element</li><li><code>nb</code>: Number of local basis functions per element</li><li><code>I</code>: Integer type for mesh indexing</li><li><code>Fun</code>: Function type for source term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/assembly_global_vectors.jl#L57-L78">source</a></section></details></article><h2 id="Initial-Solution"><a class="docs-heading-anchor" href="#Initial-Solution">Initial Solution</a><a id="Initial-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Solution" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_r⁰_z⁰!-NTuple{7, Any}"><a class="docstring-binding" href="#WaveAcoustics.compute_r⁰_z⁰!-NTuple{7, Any}"><code>WaveAcoustics.compute_r⁰_z⁰!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_r⁰_z⁰!(r⁰, z⁰, lhs_mat, input_data, mesh, dof_map, quad)</code></pre><p>Compute initial velocity and displacement fields via L2 projection.</p><p><strong>Arguments</strong></p><ul><li><code>r⁰::AbstractVector</code>: Output vector for initial velocity coefficients (modified in-place, length <code>dof_map.m</code>)</li><li><code>z⁰::AbstractVector</code>: Output vector for initial displacement coefficients (modified in-place, length <code>dof_map.m</code>)</li><li><code>lhs_mat</code>: Matrix to be factorized</li><li><code>input_data</code>: Structure containing fields <code>r₀</code>, <code>z₀</code></li><li><code>mesh::CartesianMesh{1}</code>: 1D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/initial_solution.jl#L68-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_v⁰_d⁰!-NTuple{7, Any}"><a class="docstring-binding" href="#WaveAcoustics.compute_v⁰_d⁰!-NTuple{7, Any}"><code>WaveAcoustics.compute_v⁰_d⁰!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_v⁰_d⁰!(v⁰, d⁰, lhs_mat, input_data, mesh, dof_map, quad)</code></pre><p>Compute initial velocity and displacement fields via H₀¹ projection from gradient data.</p><p><strong>Arguments</strong></p><ul><li><code>v⁰::AbstractVector</code>: Output vector for initial velocity coefficients (modified in-place, length <code>dof_map.m</code>)</li><li><code>d⁰::AbstractVector</code>: Output vector for initial displacement coefficients (modified in-place, length <code>dof_map.m</code>)</li><li><code>lhs_mat</code>: Matrix to be factorized</li><li><code>input_data</code>: Structure containing gradient fields <code>∂ₓv₀</code>, <code>∂ᵧv₀</code>, <code>∂ₓu₀</code>, <code>∂ᵧu₀</code></li><li><code>mesh::CartesianMesh{2}</code>: 2D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/initial_solution.jl#L41-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.projection_H01_2d!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{T}, Tuple{AbstractVector{T}, F1, F2, F3, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, AbstractVector{T}, AbstractVector{T}}} where {T, F1, F2, F3}"><a class="docstring-binding" href="#WaveAcoustics.projection_H01_2d!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{T}, Tuple{AbstractVector{T}, F1, F2, F3, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, AbstractVector{T}, AbstractVector{T}}} where {T, F1, F2, F3}"><code>WaveAcoustics.projection_H01_2d!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">projection_H01_2d!(uₕ_coefs, ∂ₓu, ∂ᵧu, factorized_lhs_mat, mesh, dof_map, quad, vec₁, vec₂)</code></pre><p>Compute the H₀¹ projection of a function onto a finite element subspace given its gradient components.</p><p>Solves the weak formulation (∇uₕ, ∇v) = (∇u, ∇v) for all v ∈ Vₕ, where uₕ is the projection and Vₕ is the finite element space.</p><p><strong>Arguments</strong></p><ul><li><code>uₕ_coefs::AbstractVector{T}</code>: Output vector for FEM coefficients of the projection (modified in-place, length dof_map.m)</li><li><code>∂ₓu::F1</code>: Partial derivative ∂u/∂x with signature <code>∂ₓu(x, y) → T</code></li><li><code>∂ᵧu::F2</code>: Partial derivative ∂u/∂y with signature <code>∂ᵧu(x, y) → T</code></li><li><code>factorized_lhs_mat::F3</code>: Factorized matrix (e.g., Cholesky factorization)</li><li><code>mesh::CartesianMesh{2}</code>: 2D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li><li><code>vec₁::AbstractVector{T}</code>: Work vector for RHS assembly (modified in-place, length <code>dof_map.m</code>)</li><li><code>vec₂::AbstractVector{T}</code>: Work vector for RHS assembly (modified in-place, length <code>dof_map.m</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/initial_solution.jl#L1-L18">source</a></section></details></article><h2 id="PDE-Input-Data"><a class="docs-heading-anchor" href="#PDE-Input-Data">PDE Input Data</a><a id="PDE-Input-Data-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-Input-Data" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.PDECommonData"><a class="docstring-binding" href="#WaveAcoustics.PDECommonData"><code>WaveAcoustics.PDECommonData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PDECommonData{T&lt;:Real, Fα, Ff, Fdf, Fg, F∂ₛg, Fu₀, F∂ₓu₀, F∂ᵧu₀, Fv₀, F∂ₓv₀, F∂ᵧv₀, Fz₀, Fr₀}</code></pre><p>Common configuration for coupled wave-acoustic PDE system.</p><p><strong>Mathematical Specification</strong></p><p>Wave equation on rectangular domain Ω = ]xmin,xmax[ × ]ymin,ymax[:</p><p class="math-container">\[\frac{∂²u}{∂t²} - α(t)Δu + f(u) = f₁(x,y,t) \quad \text{in } Ω\]</p><p>with homogeneous boundary conditions on Γ₀ = ∂Ω \ Γ₁.</p><p>Acoustic equation on bottom boundary Γ₁ = {(x,ymin) : x ∈ ]xmin,xmax[}:</p><p class="math-container">\[q₁\frac{∂²z}{∂t²} + q₂\frac{∂z}{∂t} + q₃z + q₄v(x,ymin,t) = f₂(x,t)\]</p><p>where v = ∂u/∂t couples the wave velocity at Γ₁ to the acoustic equation.</p><p><strong>Fields</strong></p><p><strong>Domain Configuration</strong></p><ul><li><code>pmin::NTuple{2,T}</code>: Bottom-left corner (xmin, ymin). Default: <code>(0, 0)</code></li><li><code>pmax::NTuple{2,T}</code>: Top-right corner (xmax, ymax). Default: <code>(1, 1)</code></li><li><code>t_final::T</code>: Final simulation time. Default: <code>1</code></li></ul><p><strong>Physical Parameters</strong></p><ul><li><code>q₁::T</code>: Acoustic acceleration coefficient. Default: <code>1</code></li><li><code>q₂::T</code>: Acoustic velocity coefficient. Default: <code>1</code></li><li><code>q₃::T</code>: Acoustic displacement coefficient. Default: <code>1</code></li><li><code>q₄::T</code>: Wave-acoustic coupling strength. Default: <code>1</code></li></ul><p><strong>Coefficient Functions</strong></p><ul><li><code>α::Fα</code>: Time-dependent wave diffusion coefficient α(t)</li><li><code>f::Ff</code>, <code>df::Fdf</code>: Nonlinear wave term f(s) and derivative f&#39;(s)</li><li><code>g::Fg</code>, <code>∂ₛg::F∂ₛg</code>: Nonlinear coupling function g(x,s) and s-derivative ∂ₛg(x,s)</li></ul><p><strong>Wave Initial Conditions (2D functions on Ω)</strong></p><ul><li><code>u₀::Fu₀</code>, <code>∂ₓu₀::F∂ₓu₀</code>, <code>∂ᵧu₀::F∂ᵧu₀</code>: Displacement u(x,y,0) and spatial derivatives</li><li><code>v₀::Fv₀</code>, <code>∂ₓv₀::F∂ₓv₀</code>, <code>∂ᵧv₀::F∂ᵧv₀</code>: Velocity v(x,y,0) = ∂ₜu(x,y,0) and spatial derivatives</li></ul><p><strong>Acoustic Initial Conditions (1D functions on Γ₁)</strong></p><ul><li><code>z₀::Fz₀</code>: Acoustic displacement z(x,0)</li><li><code>r₀::Fr₀</code>: Acoustic velocity r(x,0) = ∂ₜz(x,0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L1-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.PDEInputData"><a class="docstring-binding" href="#WaveAcoustics.PDEInputData"><code>WaveAcoustics.PDEInputData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PDEInputData{C&lt;:PDECommonData, Ff₁, Ff₂, Fu, Fv, Fz, Fr}</code></pre><p>Complete problem specification including source terms and analytical solutions.</p><p><strong>Fields</strong></p><ul><li><code>common::C</code>: Problem configuration (see <a href="#WaveAcoustics.PDECommonData"><code>PDECommonData</code></a>)</li><li><code>f₁::Ff₁</code>: Wave source term f₁(x,y,t) on Ω</li><li><code>f₂::Ff₂</code>: Acoustic source term f₂(x,t) on Γ₁</li><li><code>u::Fu</code>, <code>v::Fv</code>: Analytical wave solutions u(x,y,t), v(x,y,t) (if known)</li><li><code>z::Fz</code>, <code>r::Fr</code>: Analytical acoustic solutions z(x,t), r(x,t) (if known)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L82-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.example1_common_data-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#WaveAcoustics.example1_common_data-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example1_common_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">example1_common_data([T=Float64]) -&gt; PDECommonData{T}</code></pre><p>Ω = ]0,1[², f(s) = s|s|³, g(x,s) = (1+exp(-x²))(sin(s)+2s), u₀(x,y) = (x^2.4 - x) * (y^2.4 - 1) * 4, z₀(x) = sinpi(x).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L166-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.example1_manufactured-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#WaveAcoustics.example1_manufactured-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example1_manufactured</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">example1_manufactured([T=Float64]) -&gt; PDEInputData{T}</code></pre><p>Example 1 with manufactured solutions for convergence study.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L196-L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.example1_zero_source-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#WaveAcoustics.example1_zero_source-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example1_zero_source</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">example1_zero_source([T=Float64]) -&gt; PDEInputData{T}</code></pre><p>Example 1 with zero source terms for physical simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L228-L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.example2_common_data-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#WaveAcoustics.example2_common_data-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example2_common_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">example2_common_data([T=Float64]) -&gt; PDECommonData{T}</code></pre><p>Ω = ]0,1[², f(s) = 0, g(x,s) = (1+exp(-x²))s, u₀(x,y) = (x^2.4 - x) * (y^2.4 - 1) * 4, z₀(x) = sinpi(x).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L242-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.example2_manufactured-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#WaveAcoustics.example2_manufactured-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example2_manufactured</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">example2_manufactured([T=Float64]) -&gt; PDEInputData{T}</code></pre><p>Example 2 with manufactured solutions for convergence study.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L272-L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.example2_zero_source-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#WaveAcoustics.example2_zero_source-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>WaveAcoustics.example2_zero_source</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">example2_zero_source([T=Float64]) -&gt; PDEInputData{T}</code></pre><p>Example 2 with zero source terms for physical simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L301-L305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.manufactured_solution_case-Union{Tuple{T}, Tuple{PDECommonData{T}, Vararg{Any, 6}}} where T"><a class="docstring-binding" href="#WaveAcoustics.manufactured_solution_case-Union{Tuple{T}, Tuple{PDECommonData{T}, Vararg{Any, 6}}} where T"><code>WaveAcoustics.manufactured_solution_case</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">manufactured_solution_case(common, f₁, f₂, u, v, z, r) -&gt; PDEInputData</code></pre><p>Construct problem with manufactured solutions for convergence study.</p><p>Source terms <code>f₁</code> and <code>f₂</code> are computed by substituting analytical solutions into the governing PDEs (Method of Manufactured Solutions).</p><p><strong>Arguments</strong></p><ul><li><code>common::PDECommonData</code>: Problem configuration</li><li><code>f₁</code>: Manufactured wave source f₁(x,y,t)</li><li><code>f₂</code>: Manufactured acoustic source f₂(x,t)</li><li><code>u</code>, <code>v</code>: Analytical wave solutions u(x,y,t), v(x,y,t)</li><li><code>z</code>, <code>r</code>: Analytical acoustic solutions z(x,t), r(x,t)</li></ul><p><strong>See also</strong></p><p><a href="#WaveAcoustics.zero_source_case-Union{Tuple{PDECommonData{T}}, Tuple{T}} where T"><code>zero_source_case</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L104-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.zero_source_case-Union{Tuple{PDECommonData{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#WaveAcoustics.zero_source_case-Union{Tuple{PDECommonData{T}}, Tuple{T}} where T"><code>WaveAcoustics.zero_source_case</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">zero_source_case(common) -&gt; PDEInputData</code></pre><p>Construct problem with zero source terms (f₁ = f₂ = 0).</p><p>No analytical solution available. Dummy functions returning <code>nothing</code> are used for analytical solution fields.</p><p><strong>See also</strong></p><p><a href="#WaveAcoustics.manufactured_solution_case-Union{Tuple{T}, Tuple{PDECommonData{T}, Vararg{Any, 6}}} where T"><code>manufactured_solution_case</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_inputdata.jl#L134-L144">source</a></section></details></article><h2 id="PDE-Solve"><a class="docs-heading-anchor" href="#PDE-Solve">PDE Solve</a><a id="PDE-Solve-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-Solve" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.pde_solve-Union{Tuple{T}, Tuple{I}, Tuple{Tuple{I, I}, T, Any}, Tuple{Tuple{I, I}, T, Any, WaveAcoustics.ODESolver}} where {I&lt;:Integer, T&lt;:Real}"><a class="docstring-binding" href="#WaveAcoustics.pde_solve-Union{Tuple{T}, Tuple{I}, Tuple{Tuple{I, I}, T, Any}, Tuple{Tuple{I, I}, T, Any, WaveAcoustics.ODESolver}} where {I&lt;:Integer, T&lt;:Real}"><code>WaveAcoustics.pde_solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pde_solve(Nx, τ, input_data)</code></pre><p>Solve coupled wave-acoustic PDE system and compute L∞(0,T;L²) errors.</p><p><strong>Arguments</strong></p><ul><li><code>Nx::NTuple{2,Integer}</code>: Number of elements per direction</li><li><code>τ::Real</code>: Time step size</li><li><code>input_data::PDEInputData</code>: Problem configuration with manufactured solution </li><li><code>solver::ODESolver</code>: Time integration scheme (default: <code>CrankNicolson()</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>(LooL2_v, LooL2_u, LooL2_r, LooL2_z)</code>: L∞(0,T;L²) errors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_solve.jl#L12-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.solve_ode-Tuple{CrankNicolson, Vararg{Any, 12}}"><a class="docstring-binding" href="#WaveAcoustics.solve_ode-Tuple{CrankNicolson, Vararg{Any, 12}}"><code>WaveAcoustics.solve_ode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_ode(::CrankNicolson, v⁰, d⁰, r⁰, z⁰, τ, ...)</code></pre><p>Crank-Nicolson time integration for the semi-discrete system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_solve.jl#L110-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.solve_ode-Tuple{CrankNicolsonLinearized, Vararg{Any, 12}}"><a class="docstring-binding" href="#WaveAcoustics.solve_ode-Tuple{CrankNicolsonLinearized, Vararg{Any, 12}}"><code>WaveAcoustics.solve_ode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_ode(::CrankNicolsonLinearized, v⁰, d⁰, r⁰, z⁰, τ, ...)</code></pre><p>Linearized Crank-Nicolson time integration for the semi-discrete system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/pde_solve.jl#L124-L128">source</a></section></details></article><h2 id="EDO-Solve"><a class="docs-heading-anchor" href="#EDO-Solve">EDO Solve</a><a id="EDO-Solve-1"></a><a class="docs-heading-anchor-permalink" href="#EDO-Solve" title="Permalink"></a></h2><h3 id="Crank-Nicolson-Method"><a class="docs-heading-anchor" href="#Crank-Nicolson-Method">Crank-Nicolson Method</a><a id="Crank-Nicolson-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Crank-Nicolson-Method" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="WaveAcoustics.CNCache"><a class="docstring-binding" href="#WaveAcoustics.CNCache"><code>WaveAcoustics.CNCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CNCache{T}</code></pre><p>Cache structure for Crank-Nicolson solver.</p><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L223-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.CNCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T"><a class="docstring-binding" href="#WaveAcoustics.CNCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T"><code>WaveAcoustics.CNCache</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CNCache(m₁::Integer, m₂::Integer, ::Type{T}) where T</code></pre><p>Construct cache with all vectors initialized to zero.</p><p><strong>Arguments</strong></p><ul><li><code>m₁</code>: Number of free DOFs in 2D domain Ω</li><li><code>m₂</code>: Number of free DOFs on 1D boundary Γ₁  </li><li><code>T</code>: Element type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L239-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_A₁₁!-Tuple{AbstractMatrix, AbstractMatrix, Real, Real, AbstractMatrix}"><a class="docstring-binding" href="#WaveAcoustics.compute_A₁₁!-Tuple{AbstractMatrix, AbstractMatrix, Real, Real, AbstractMatrix}"><code>WaveAcoustics.compute_A₁₁!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_A₁₁!(A₁₁, M_m₁xm₁, τ²_4, α_half, K_m₁xm₁)</code></pre><p>Compute system matrix A₁₁ = M<em>m₁×m₁ + (τ²/4)α(tₙ₊₁/₂)K</em>m₁×m₁.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L264-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_A₁₂!-Tuple{AbstractMatrix, Real, Real, AbstractMatrix}"><a class="docstring-binding" href="#WaveAcoustics.compute_A₁₂!-Tuple{AbstractMatrix, Real, Real, AbstractMatrix}"><code>WaveAcoustics.compute_A₁₂!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_A₁₂!(A₁₂, τ_2, α_half, M_m₁xm₂)</code></pre><p>Compute system matrix A₁₂ = -(τ/2)α(tₙ₊₁/₂)M_m₁×m₂.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L281-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_DHX₁₁!-NTuple{13, Any}"><a class="docstring-binding" href="#WaveAcoustics.compute_DHX₁₁!-NTuple{13, Any}"><code>WaveAcoustics.compute_DHX₁₁!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_DHX₁₁!(DHX₁₁, A₁₁, v̂ⁿ_m₂, d̂ⁿ, input_data, mesh1D, mesh2D,
               dof_map_m₁, dof_map_m₂, quad, τα_2, τ²_4, m₂)</code></pre><pre><code class="language-julia hljs">DHX₁₁ = A₁₁ + (τ²/4)⋅DF(d̂ⁿ) + (τ/2)α(tₙ₋₁/₂)⋅DG(v̂ⁿ_m₂)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L457-L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_Lm₁!-NTuple{13, Any}"><a class="docstring-binding" href="#WaveAcoustics.compute_Lm₁!-NTuple{13, Any}"><code>WaveAcoustics.compute_Lm₁!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_Lm₁!(Lm₁, vⁿ⁻¹, rⁿ⁻¹, vec_d_v, matrices, input_data, mesh2D, dof_map_m₁, quad, τ, t_half, α_half, cache)</code></pre><pre><code class="language-julia hljs">Lm₁ = M_m₁×m₁⋅vⁿ⁻¹ - τα(tₙ₊₁/₂)K_m₁×m₁⋅(dⁿ⁻¹+(τ/4)⋅vⁿ⁻¹) + (τ/2)α(tₙ₊₁/₂)M_m₁×m₂⋅rⁿ⁻¹ + τF(f₁(tₙ₊₁/₂))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L301-L307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_Lm₂!-NTuple{15, Any}"><a class="docstring-binding" href="#WaveAcoustics.compute_Lm₂!-NTuple{15, Any}"><code>WaveAcoustics.compute_Lm₂!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_Lm₂!(Lm₂, rⁿ⁻¹, zⁿ⁻¹, vⁿ⁻¹, matrices, input_data, mesh1D, dof_map_m₂, quad, τ, t_half, τq₄_2, τq₃, cst_q, cache)</code></pre><pre><code class="language-julia hljs">Lm₂ = M_m₂×m₂⋅(cst_q⋅rⁿ⁻¹ - τq₃⋅zⁿ⁻¹) - (τ/2)q₄⋅M_m₂×m₁⋅vⁿ⁻¹ + τ⋅F(f₂(tₙ₊₁/₂))</code></pre><p>where <code>cst_q = q₁ - (τ/2)q₂ - (τ²/4)q₃</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L344-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_minusHX!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Any, Any, Any, Any, Any, Any, T, T, T, WaveAcoustics.CNCache{T}}} where T"><a class="docstring-binding" href="#WaveAcoustics.compute_minusHX!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, Any, Any, Any, Any, Any, Any, T, T, T, WaveAcoustics.CNCache{T}}} where T"><code>WaveAcoustics.compute_minusHX!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_minusHX!(minusHX, vⁿ, v̂ⁿ_m₂, d̂ⁿ, rⁿ, A₁₁, A₂₂, M_m₂xm₂, Lm₁, Lm₂, 
                 input_data, mesh1D, mesh2D, dof_map_m₁, dof_map_m₂, quad, 
                 τ, τq₄_2, α_half, cache)</code></pre><p>Compute negative residual -H(X) for Newton&#39;s method.</p><p>The residual H(X) represents the nonlinear system:</p><pre><code class="language-julia hljs">H(X) = [A₁₁⋅vⁿ - (τ/2)α(tₙ₊₁/₂)M_m₁×m₂⋅rⁿ + τα(tₙ₊₁/₂)G(v̂ⁿ_m₂) + τF(d̂ⁿ) - Lm₁]
       [(τ/2)q₄⋅M_m₂×m₁⋅vⁿ + A₂₂⋅rⁿ - Lm₂                                    ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L377-L389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.crank_nicolson-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.crank_nicolson-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T&lt;:Real"><code>WaveAcoustics.crank_nicolson</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">crank_nicolson(v⁰, d⁰, r⁰, z⁰, τ, input_data, mesh1D, mesh2D, 
               dof_map_m₁, dof_map_m₂, quad, matrices)</code></pre><p>Solve coupled wave-acoustic PDE system using Crank-Nicolson time integration.</p><p><strong>Arguments</strong></p><ul><li><code>v⁰::AbstractVector{T}</code>: Initial wave velocity in Ω</li><li><code>d⁰::AbstractVector{T}</code>: Initial wave displacement in Ω</li><li><code>r⁰::AbstractVector{T}</code>: Initial acoustic velocity on Γ₁</li><li><code>z⁰::AbstractVector{T}</code>: Initial acoustic displacement on Γ₁</li><li><code>τ::T</code>: Time step size</li><li><code>input_data</code>: Problem configuration with manufactured solution</li><li><code>mesh1D::CartesianMesh{1}</code>: 1D mesh for boundary Γ₁</li><li><code>mesh2D::CartesianMesh{2}</code>: 2D mesh for domain Ω</li><li><code>dof_map_m₁::DOFMap</code>: DOF mapping for 2D finite element space</li><li><code>dof_map_m₂::DOFMap</code>: DOF mapping for 1D boundary space</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li><li><code>matrices</code>: Preassembled global matrices</li></ul><p><strong>Returns</strong></p><p>Named tuple with L² errors at each time step:</p><ul><li><code>v</code>: Wave velocity errors in Ω</li><li><code>d</code>: Wave displacement errors in Ω</li><li><code>r</code>: Acoustic velocity errors on Γ₁</li><li><code>z</code>: Acoustic displacement errors on Γ₁</li></ul><p><strong>Algorithm</strong></p><p>Uses Crank-Nicolson for time discretization with Newton iteration to handle nonlinearities f(u) and g(x,v).  The method is second-order accurate in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson.jl#L1-L31">source</a></section></details></article><h3 id="Linearized-Crank-Nicolson-Method"><a class="docs-heading-anchor" href="#Linearized-Crank-Nicolson-Method">Linearized Crank-Nicolson Method</a><a id="Linearized-Crank-Nicolson-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Linearized-Crank-Nicolson-Method" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="WaveAcoustics.CNLCache"><a class="docstring-binding" href="#WaveAcoustics.CNLCache"><code>WaveAcoustics.CNLCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CNLCache{T}</code></pre><p>Cache structure for linearized Crank-Nicolson solver.</p><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson_linearized.jl#L262-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.CNLCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T"><a class="docstring-binding" href="#WaveAcoustics.CNLCache-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T"><code>WaveAcoustics.CNLCache</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CNLCache(m₁::Integer, m₂::Integer, ::Type{T}) where T</code></pre><p>Construct cache with all vectors initialized to zero.</p><p><strong>Arguments</strong></p><ul><li><code>m₁</code>: Number of free DOFs in 2D domain Ω</li><li><code>m₂</code>: Number of free DOFs on 1D boundary Γ₁  </li><li><code>T</code>: Element type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson_linearized.jl#L278-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_A!-Union{Tuple{S}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, S}, LinearAlgebra.Symmetric{T, S}, T, T, LinearAlgebra.Symmetric{T, S}}} where {T, S&lt;:(SparseArrays.SparseMatrixCSC{T})}"><a class="docstring-binding" href="#WaveAcoustics.compute_A!-Union{Tuple{S}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, S}, LinearAlgebra.Symmetric{T, S}, T, T, LinearAlgebra.Symmetric{T, S}}} where {T, S&lt;:(SparseArrays.SparseMatrixCSC{T})}"><code>WaveAcoustics.compute_A!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_A!(A, M_m₁xm₁, τ²_4, α_half, K_m₁xm₁)</code></pre><p>Compute system matrix <code>A = M_m₁×m₁ + (τ²/4)α(tₙ₊₁/₂)K_m₁×m₁</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson_linearized.jl#L424-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_rⁿ!-Union{Tuple{Ff₂}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Any, Ff₂, T, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, WaveAcoustics.CNLCache}} where {T, Ff₂}"><a class="docstring-binding" href="#WaveAcoustics.compute_rⁿ!-Union{Tuple{Ff₂}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Any, Ff₂, T, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, WaveAcoustics.CNLCache}} where {T, Ff₂}"><code>WaveAcoustics.compute_rⁿ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_rⁿ!(rⁿ, rⁿ⁻¹, zⁿ⁻¹, v_ast_n, cst, M_m₂xm₂_factorized, f₂, t_half, mesh1D, dof_map_m₂, quad, cache)</code></pre><p>Compute <code>rⁿ = cst[1]*rⁿ⁻¹ - cst[2]*zⁿ⁻¹ - cst[3]*v_ast_n + M_m₂xm₂ \ (cst[4]*F(f₂(tₙ₋₁/₂)))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson_linearized.jl#L302-L306">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_vⁿ!-Union{Tuple{Ff1}, Tuple{Ff}, Tuple{Fg}, Tuple{Fα}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Fα, Fg, Ff, Ff1, T, T, T, T, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any, Any, WaveAcoustics.CNLCache}} where {T, Fα, Fg, Ff, Ff1}"><a class="docstring-binding" href="#WaveAcoustics.compute_vⁿ!-Union{Tuple{Ff1}, Tuple{Ff}, Tuple{Fg}, Tuple{Fα}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Fα, Fg, Ff, Ff1, T, T, T, T, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any, Any, WaveAcoustics.CNLCache}} where {T, Fα, Fg, Ff, Ff1}"><code>WaveAcoustics.compute_vⁿ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_vⁿ!(vⁿ, vⁿ⁻¹, dⁿ⁻¹, rⁿ, rⁿ⁻¹, v_ast_n, d_ast_n, α, g, f, f₁, t_half, τ, τ_4, τ²_4, mesh1D, mesh2D, dof_map_m₁, dof_map_m₂, quad, matrices, A, cache)</code></pre><p>Assemble and solve <code>A vⁿ = b</code>, where:</p><ul><li><code>A = M_m₁×m₁ + (τ²/4)α(tₙ₋₁/₂)K_m₁×m₁</code></li><li><code>b = M_m₁×m₁ vⁿ⁻¹ - τα(tₙ₋₁/₂)K_m₁×m₁((τ/4)vⁿ⁻¹ + dⁿ⁻¹) + (τ/2)α(tₙ₋₁/₂)M_m₂×m₂(rⁿ + rⁿ⁻¹) - τα(tₙ₋₁/₂)G(v_ast_n) - τF(d_ast_n) + τF(f₁(tₙ₋₁/₂))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson_linearized.jl#L339-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.crank_nicolson_linearized-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T&lt;:Real"><a class="docstring-binding" href="#WaveAcoustics.crank_nicolson_linearized-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, T, Any, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup, Any}} where T&lt;:Real"><code>WaveAcoustics.crank_nicolson_linearized</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">crank_nicolson_linearized(v⁰, d⁰, r⁰, z⁰, τ, input_data, mesh1D, mesh2D, 
                          dof_map_m₁, dof_map_m₂, quad, matrices)</code></pre><p>Solve coupled wave-acoustic PDE system using linearized Crank-Nicolson time integration.</p><p><strong>Arguments</strong></p><ul><li><code>v⁰::AbstractVector{T}</code>: Initial wave velocity in Ω</li><li><code>d⁰::AbstractVector{T}</code>: Initial wave displacement in Ω</li><li><code>r⁰::AbstractVector{T}</code>: Initial acoustic velocity on Γ₁</li><li><code>z⁰::AbstractVector{T}</code>: Initial acoustic displacement on Γ₁</li><li><code>τ::T</code>: Time step size</li><li><code>input_data</code>: Problem configuration with manufactured solution</li><li><code>mesh1D::CartesianMesh{1}</code>: 1D mesh for boundary Γ₁</li><li><code>mesh2D::CartesianMesh{2}</code>: 2D mesh for domain Ω</li><li><code>dof_map_m₁::DOFMap</code>: DOF mapping for 2D finite element space</li><li><code>dof_map_m₂::DOFMap</code>: DOF mapping for 1D boundary space</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li><li><code>matrices</code>: Preassembled global matrices</li></ul><p><strong>Returns</strong></p><p>Named tuple containing L² errors at each time step:</p><ul><li><code>v</code>: Wave velocity errors in Ω</li><li><code>d</code>: Wave displacement errors in Ω</li><li><code>r</code>: Acoustic velocity errors on Γ₁</li><li><code>z</code>: Acoustic displacement errors on Γ₁</li></ul><p><strong>Algorithm</strong></p><ul><li>Implements second-order accurate linearized Crank-Nicolson scheme. Nonlinear terms  <code>f(u)</code> and <code>g(x,v)</code>, along with the coupling term <code>q₄v</code> in the acoustic equation,  are evaluated using values from previous time step(s) to decouple the system and  avoid implicit nonlinear solves.</li><li><strong>Temporal refinement requirement</strong>: Preliminary tests suggest the algorithm requires  sufficiently refined time steps for stability. The necessary refinement may be related  to the variation of the boundary nonlinearity <code>g</code>. Further investigation needed.</li><li><strong>Note on validation strategy</strong>: During implementation validation, the exact solution  was temporarily substituted for <code>v_ast_n</code> in the nonlinear term <code>g(x,v)</code>, which  allowed verification of all other algorithmic components. The current implementation  correctly uses the extrapolated velocity <code>v_ast_n</code> as specified in the algorithm.  Convergence analysis with fixed, well-refined τ demonstrates correct behavior; issues  observed in earlier tests with coupled refinement (h = τ) require further analysis.</li></ul><p><strong>Examples</strong></p><p>Spatial convergence with τ = 2⁻¹² (well-refined) demonstrates optimal second-order convergence:</p><pre><code class="language-julia hljs">julia&gt; results = convergence_test_spatial(input_data=example1_manufactured(), solver=CrankNicolsonLinearized(), τ_fixed=2^(-12));
julia&gt; print_convergence_table(results)
==============================================================================================================
Spatial convergence (τ = 0.000244140625 fixed) with CrankNicolsonLinearized
==============================================================================================================
   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z
--------------------------------------------------------------------------------------------------------------
    8     -2.50   -12.00    4.68e-03    0.000    1.12e-02    0.000    1.50e-02    0.000    1.14e-02    0.000
   16     -3.50   -12.00    1.18e-03    1.983    2.80e-03    2.005    3.61e-03    2.057    2.79e-03    2.036
   32     -4.50   -12.00    2.97e-04    1.994    6.99e-04    2.002    8.88e-04    2.022    6.92e-04    2.012
   64     -5.50   -12.00    7.44e-05    1.998    1.75e-04    2.001    2.21e-04    2.009    1.72e-04    2.004
==============================================================================================================</code></pre><p>Insufficient temporal refinement (τ = 2⁻¹⁰) leads to algorithm failure for <code>example1_manufactured()</code>:</p><pre><code class="language-julia hljs">julia&gt; results = convergence_test_spatial(input_data=example1_manufactured(), solver=CrankNicolsonLinearized(), τ_fixed=2^(-10));
julia&gt; print_convergence_table(results)
==============================================================================================================
Spatial convergence (τ = 0.0009765625 fixed) with CrankNicolsonLinearized
==============================================================================================================
   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z
--------------------------------------------------------------------------------------------------------------
    8     -2.50   -10.00    4.68e-03    0.000    1.12e-02    0.000    1.50e-02    0.000    1.14e-02    0.000
   16     -3.50   -10.00    1.18e-03    1.983    2.80e-03    2.005    3.61e-03    2.057    2.79e-03    2.036
   32     -4.50   -10.00    6.73e-02   -5.830    2.15e-03    0.380    4.82e-03   -0.419    2.54e-03    0.138
   64     -5.50   -10.00         NaN      NaN         NaN      NaN         NaN      NaN         NaN      NaN
==============================================================================================================</code></pre><p>However, the same temporal refinement (τ = 2⁻¹⁰) is sufficient for  <code>example2_manufactured()</code>, suggesting sensitivity to the specific form of <code>g</code>:</p><pre><code class="language-julia hljs">julia&gt; results = convergence_test_spatial(input_data=example2_manufactured(), solver=CrankNicolsonLinearized(), τ_fixed=2^(-10));
julia&gt; print_convergence_table(results)
==============================================================================================================
Spatial convergence (τ = 0.0009765625 fixed) with CrankNicolsonLinearized
==============================================================================================================
   Nx    log₂(h)  log₂(τ)   L∞L²_v     rate_v    L∞L²_d     rate_d    L∞L²_r     rate_r    L∞L²_z     rate_z
--------------------------------------------------------------------------------------------------------------
    8     -2.50   -10.00    4.65e-03    0.000    1.21e-02    0.000    5.05e-03    0.000    6.54e-03    0.000
   16     -3.50   -10.00    1.16e-03    2.000    3.02e-03    2.003    1.22e-03    2.047    1.61e-03    2.026
   32     -4.50   -10.00    2.91e-04    1.999    7.55e-04    2.002    3.02e-04    2.018    4.00e-04    2.007
   64     -5.50   -10.00    7.28e-05    1.999    1.88e-04    2.003    7.50e-05    2.008    9.97e-05    2.002
==============================================================================================================</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/crank_nicolson_linearized.jl#L1-L93">source</a></section></details></article><h2 id="Error-norms"><a class="docs-heading-anchor" href="#Error-norms">Error norms</a><a id="Error-norms-1"></a><a class="docs-heading-anchor-permalink" href="#Error-norms" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.L2_error_1d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:Real, Fun}"><a class="docstring-binding" href="#WaveAcoustics.L2_error_1d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{1}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:Real, Fun}"><code>WaveAcoustics.L2_error_1d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">L2_error_1d(u, uₕ_coefs, mesh, dof_map, quad)</code></pre><p>Compute the L2 error norm ||u - uₕ||_L2 between exact and FEM solutions.</p><p><strong>Arguments</strong></p><ul><li><code>u::F</code>: Exact solution function with signature <code>u(x) → T</code></li><li><code>uₕ_coefs::AbstractVector{T}</code>: DOF coefficients of the FEM solution (length = <code>dof_map.m</code>)</li><li><code>mesh::CartesianMesh{1}</code>: 1D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: L2 norm ||u - uₕ||_L2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/error_norms.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.L2_error_2d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:Real, Fun}"><a class="docstring-binding" href="#WaveAcoustics.L2_error_2d-Union{Tuple{Fun}, Tuple{T}, Tuple{Fun, AbstractVector{T}, WaveAcoustics.CartesianMesh{2}, WaveAcoustics.DOFMap, WaveAcoustics.QuadratureSetup}} where {T&lt;:Real, Fun}"><code>WaveAcoustics.L2_error_2d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">L2_error_2d(u, uₕ_coefs, mesh, dof_map, quad)</code></pre><p>Compute the L2 error norm ||u - uₕ||_L2 between exact and FEM solutions.</p><p><strong>Arguments</strong></p><ul><li><code>u::F</code>: Exact solution function with signature <code>u(x, y) → T</code></li><li><code>uₕ_coefs::AbstractVector{T}</code>: DOF coefficients of the FEM solution (length = <code>dof_map.m</code>)</li><li><code>mesh::CartesianMesh{2}</code>: 2D Cartesian mesh</li><li><code>dof_map::DOFMap</code>: DOF mapping with <code>EQoLG</code> connectivity and <code>m</code> free DOFs</li><li><code>quad::QuadratureSetup</code>: Precomputed quadrature data</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: L2 norm ||u - uₕ||_L2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/error_norms.jl#L59-L73">source</a></section></details></article><h2 id="Convergence-test"><a class="docs-heading-anchor" href="#Convergence-test">Convergence test</a><a id="Convergence-test-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-test" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WaveAcoustics.compute_element_diameter-Union{Tuple{T}, Tuple{I}, Tuple{I, Tuple{T, T}, Tuple{T, T}}} where {I&lt;:Integer, T&lt;:AbstractFloat}"><a class="docstring-binding" href="#WaveAcoustics.compute_element_diameter-Union{Tuple{T}, Tuple{I}, Tuple{I, Tuple{T, T}, Tuple{T, T}}} where {I&lt;:Integer, T&lt;:AbstractFloat}"><code>WaveAcoustics.compute_element_diameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_element_diameter(Nx, pmin, pmax)</code></pre><p>Compute element diameter h = √(Δx² + Δy²) for uniform rectangular mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/convergence_test.jl#L109-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.convergence_test_coupled-Tuple{}"><a class="docstring-binding" href="#WaveAcoustics.convergence_test_coupled-Tuple{}"><code>WaveAcoustics.convergence_test_coupled</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convergence_test_coupled(;input_data, solver, Nx_exp_range)</code></pre><p>Perform coupled space-time convergence test with τ = h.</p><p>Varies spatial and temporal discretization together, assuming linear basis functions. Convergence rates are computed as log₂(error<em>{i-1} / error</em>i) between successive refinements.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>input_data</code>: PDE input data (default: <code>example1_common_data()</code>)</li><li><code>solver::ODESolver</code>: Time integration method (default: <code>CrankNicolson()</code>)</li><li><code>Nx_exp_range</code>: Grid refinement exponents (default: 3:6 → Nx = 8, 16, 32, 64)</li></ul><p><strong>Returns</strong></p><p><code>NamedTuple</code> with fields: <code>test_info</code>, <code>Nx</code>, <code>h</code>, <code>τ</code>, <code>errors</code>, <code>rates</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/convergence_test.jl#L4-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.convergence_test_spatial-Tuple{}"><a class="docstring-binding" href="#WaveAcoustics.convergence_test_spatial-Tuple{}"><code>WaveAcoustics.convergence_test_spatial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convergence_test_spatial(;input_data, solver, Nx_exp_range, τ_fixed)</code></pre><p>Perform spatial convergence test with fixed time step.</p><p>Varies mesh size h while keeping temporal discretization τ constant to isolate spatial discretization error.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>input_data</code>: PDE input data (default: <code>example1_common_data()</code>)</li><li><code>solver::ODESolver</code>: Time integration method (default: <code>CrankNicolson()</code>)</li><li><code>Nx_exp_range</code>: Grid refinement exponents (default: 3:6)</li><li><code>τ_fixed::Real</code>: Fixed time step (default: 2^(-7))</li></ul><p><strong>Returns</strong></p><p><code>NamedTuple</code> with fields: <code>test_info</code>, <code>Nx</code>, <code>h</code>, <code>τ</code>, <code>errors</code>, <code>rates</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/convergence_test.jl#L36-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.convergence_test_temporal-Tuple{}"><a class="docstring-binding" href="#WaveAcoustics.convergence_test_temporal-Tuple{}"><code>WaveAcoustics.convergence_test_temporal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convergence_test_temporal(input_data; solver, τ_exp_range, Nx_fixed)</code></pre><p>Perform temporal convergence test with fixed spatial grid.</p><p>Varies time step τ while keeping mesh size h constant to isolate temporal discretization error.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>input_data</code>: PDE input data (default: <code>example1_common_data()</code>)</li><li><code>solver::ODESolver</code>: Time integration method (default: <code>CrankNicolson()</code>)</li><li><code>τ_exp_range</code>: Time step refinement exponents (default: 3:6 → τ = 2^(-3), ..., 2^(-6))</li><li><code>Nx_fixed::Int</code>: Fixed grid size per dimension (default: 2^8)</li></ul><p><strong>Returns</strong></p><p><code>NamedTuple</code> with fields: <code>test_info</code>, <code>Nx</code>, <code>h</code>, <code>τ</code>, <code>errors</code>, <code>rates</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/convergence_test.jl#L70-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.print_convergence_table-Tuple{Any}"><a class="docstring-binding" href="#WaveAcoustics.print_convergence_table-Tuple{Any}"><code>WaveAcoustics.print_convergence_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_convergence_table(results)</code></pre><p>Display formatted convergence table from convergence test results.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">results = convergence_test_coupled()
print_convergence_table(results)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/convergence_test.jl#L187-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="WaveAcoustics.run_convergence_study-Tuple{Any, Any, Any, Any, WaveAcoustics.ODESolver, String}"><a class="docstring-binding" href="#WaveAcoustics.run_convergence_study-Tuple{Any, Any, Any, Any, WaveAcoustics.ODESolver, String}"><code>WaveAcoustics.run_convergence_study</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_convergence_study(Nx_values, h_values, τ_values, input_data, solver, test_info)</code></pre><p>Execute convergence study computing error norms and convergence rates.</p><p>Solves the PDE for each refinement level using the specified <code>solver</code>, computes  L∞(L²) error norms for all fields, and calculates convergence rates as  log₂(error<em>{i-1} / error</em>i) between successive refinements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bacarmo/WaveAcoustics.jl/blob/c288b73615cf43ca00e8e4a17ebc8f746fc2a465/src/convergence_test.jl#L126-L134">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/example2/">« Example 2</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 5 February 2026 03:43">Thursday 5 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
